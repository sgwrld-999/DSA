# **76. Minimum Window Substring – Notes**

---

## **Problem Summary**

We are given two strings `s` and `t`.

We must find the **smallest substring of `s`** that contains **all characters of `t` (including duplicates)**.

If no such substring exists, return an empty string `""`.

**Key idea:**
This is a **sliding window + frequency counting** problem where we:

* Expand the window to satisfy the requirement
* Shrink it to get the minimum length

---

# **Brute Force Approach (Very Slow – O(n³) / O(n²))**

1. Generate all substrings of `s`.
2. For each substring, check whether it contains all characters of `t` with correct frequencies.
3. Track the minimum-length valid substring.

```cpp
string ans = "";
for (int i = 0; i < s.size(); i++) {
    for (int j = i; j < s.size(); j++) {
        string sub = s.substr(i, j - i + 1);
        if (isValid(sub, t)) {
            if (ans == "" || sub.size() < ans.size())
                ans = sub;
        }
    }
}
```

**Why it's slow:**

* O(n²) substrings
* Validity check costs O(n)
* Overall complexity becomes too large

So we need an optimized sliding window approach.

---

# **Optimized Approach – Sliding Window + Frequency Map**

### **Core Idea**

* Use two pointers `start` and `end` to maintain a window
* Track required characters using a frequency array
* Expand until the window becomes valid
* Shrink to find the minimum window

---

## **Key Observations**

1. We only care about characters present in `t`.
2. A window is **valid** when it contains all required characters of `t`.
3. Once valid, we try shrinking from the left to minimize the window.
4. Each character is processed at most twice → linear time.

---

# **Code with Meaningful Variable Names**

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.empty() || t.empty() || s.size() < t.size())
            return "";

        int freq[128] = {0};
        for (char c : t)
            freq[c]++;

        int requiredChars = t.size();
        int left = 0, right = 0;
        int minWindowLength = INT_MAX;
        int minWindowStart = 0;

        while (right < s.size()) {
            if (freq[s[right]] > 0)
                requiredChars--;

            freq[s[right]]--;
            right++;

            while (requiredChars == 0) {
                if (right - left < minWindowLength) {
                    minWindowLength = right - left;
                    minWindowStart = left;
                }

                freq[s[left]]++;
                if (freq[s[left]] > 0)
                    requiredChars++;

                left++;
            }
        }

        return minWindowLength == INT_MAX
                   ? ""
                   : s.substr(minWindowStart, minWindowLength);
    }
};
```

---

# **Step-by-Step Explanation**

### **1. Build frequency map of `t`**

* Store how many times each character is required

### **2. Expand the window (`right` pointer)**

* Add `s[right]` to the window
* If it was needed, decrement `requiredChars`

### **3. When window becomes valid**

`requiredChars == 0`

* All characters of `t` are now present
* Update minimum window length

### **4. Shrink the window (`left` pointer)**

* Remove characters from the left
* If a required character is removed, window becomes invalid again

---

# **Why Does This Work?**

* The window only grows until it becomes valid
* Once valid, it shrinks as much as possible
* Guarantees the **minimum-length valid window**

---

# **Dry Run (Short Example)**

`s = "ADOBECODEBANC"`
`t = "ABC"`

| Window | Valid | Action       |
| ------ | ----- | ------------ |
| ADOBEC | Yes   | Update min   |
| DOBEC  | No    | Shrink stops |
| CODEBA | No    | Expand       |
| BANC   | Yes   | Update min   |

Final Answer: `"BANC"`

---

# **Time and Space Complexity**

* **Time:** O(n)
  Each character is processed at most twice.
* **Space:** O(1)
  Fixed-size frequency array (ASCII characters).

---

## **Key Interview Takeaway**

> ❝ Minimum Window problems follow a fixed pattern:
> Expand → Validate → Shrink → Optimize ❞
>
> Use frequency maps and a `requiredCount` variable to track validity efficiently.
