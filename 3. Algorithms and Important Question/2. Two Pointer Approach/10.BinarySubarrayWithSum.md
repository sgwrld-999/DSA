# Problem Statement

You are given:

* A binary array `nums` (containing only `0` and `1`).
* An integer `k`.

Your task is to return the **number of non-empty subarrays** whose **sum is exactly equal to `k`**.

A subarray is a **contiguous** part of the array.

---

# Thought Process

### **1. What is the problem asking?**

We want to count **all continuous subarrays** such that:

```
sum(subarray) = k
```

Since the array contains only `0` and `1`, subarray sums increase monotonically when the window expands, which allows efficient counting techniques using sliding windows or prefix-based logic.

---

### **2. First Idea (Brute Force)**

Try every possible subarray:

1. Fix a starting index `start`.
2. Expand an ending index `end`.
3. Maintain the running sum.
4. Whenever `sum == k`, increase the answer.

This approach is simple but inefficient because we inspect all possible subarrays directly.

---

### **3. Data Structure Thoughts**

| Purpose                                       | Data Structure               | Why?                                      |
| --------------------------------------------- | ---------------------------- | ----------------------------------------- |
| Track sum of current subarray                 | integer variable             | Constant-time update                      |
| Window expansion and shrinking                | Two pointers `left`, `right` | Ideal for non-negative arrays (0/1 only)  |
| Efficient counting of subarrays meeting a sum | Sliding window               | Enables O(n) solution for “at most k” sum |

---

### **4. Why Sliding Window?**

Because the array has **only non-negative numbers**, expanding the window always increases or keeps the sum unchanged.
This satisfies the monotonicity requirement needed for efficient sliding window logic.

Key insight:

```
subarrays with sum exactly k
= subarrays with sum ≤ k  –  subarrays with sum ≤ (k−1)
```

This reformulation transforms the problem into counting **at most k**, which sliding window handles very well.

The window only moves forward, making the solution linear time.

---

# ## Brute Force Approach (O(n²))

### **Idea**

Try every possible subarray:

1. Loop through each starting point `start`.
2. For every `start`, expand `end` and maintain a running sum.
3. If `sum == k`, increment counter.

Because every subarray is explicitly checked, the time complexity is quadratic.

---

### **Complexity**

* **Time:** `O(n²)`
  Each of the `n` starting points explores all suffixes.
* **Space:** `O(1)`
  Only a few integer variables.

---

### Brute Force Code

```cpp
int numSubarraysWithSum(vector<int>& nums, int goal) {
    int count = 0;

    for (int start = 0; start < nums.size(); ++start) {
        int sum = 0;

        for (int end = start; end < nums.size(); ++end) {
            sum += nums[end];

            if (sum == goal) {
                count++;
            }
        }
    }

    return count;
}
```

---

# ## Intuition

Since all numbers are **0 or 1**, sums always increase as the window expands.
This is extremely helpful, because:

```
If we can count all subarrays with sum ≤ k,
we can find the number with sum exactly k.
```

This leads to the key identity:

```
exact_sum(k) = atMost(k) – atMost(k−1)
```

Where `atMost(x)` counts the number of subarrays whose sum is ≤ x.

---

# ## Optimal Approach (Sliding Window)

### **Technique**

Define a helper function:

```
count_arrays(nums, k) = number of subarrays with sum ≤ k
```

This uses a sliding window:

1. Expand `right` and add `nums[right]` to `sum`.

2. If `sum > k`, shrink the window from the left until valid.

3. At each step, the number of valid subarrays ending at `right` is:

   ```
   right - left + 1
   ```

4. Summing these counts for all right gives total subarrays with sum ≤ k.

Then final result:

```
exact_sum(k) = count_arrays(k) – count_arrays(k−1)
```

This difference removes the overcounted part.

---

### **Algorithm Summary**

1. Use sliding window to count **all subarrays with sum ≤ k**.
2. Repeat to count **all subarrays with sum ≤ (k−1)**.
3. Subtract the two results.
4. The remaining portion consists only of subarrays with sum exactly `k`.

---

# ## Complexity

* **Time:** `O(n)`
  Each pointer moves at most once.
* **Space:** `O(1)`
  Only `sum`, `left`, `right`, and counters are used.

---

# ## Optimal Code (O(n) Sliding Window)

```cpp
class Solution {
  public:
    int count_arrays(vector<int>& nums, int k){
        if (k < 0) return 0;

        int left = 0;
        int sum = 0;
        int count = 0;

        for (int right = 0; right < nums.size(); right++) {
            sum += nums[right];

            while (sum > k) {
                sum -= nums[left];
                left++;
            }

            count += (right - left + 1);
        }

        return count;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return count_arrays(nums, k) - count_arrays(nums, k - 1);
    }
};
```

---

# ## Key Pattern to Remember

This method works **only when all numbers are non-negative**, because sliding window depends on sum increasing when the window expands.

General identity:

```
count(sum == k) = count(sum ≤ k) – count(sum ≤ k−1)
```

This pattern appears in:

* Binary subarray sum
* Subarrays with at most K distinct integers
* Subarrays with sum ≤ K
* Count subarrays divisible by K (variation with prefix sums)

---
