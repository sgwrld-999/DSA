# **1248. Count Number of Nice Subarrays – Notes**

---

## **Problem Summary**

We are given an integer array `nums` and an integer `k`.

A **nice subarray** is a contiguous subarray that contains **exactly `k` odd numbers**.

Our task is to count the number of such subarrays.

**Key idea:**
This problem can be reduced to the **Binary Subarrays With Sum** problem by treating:

* **odd numbers → 1**
* **even numbers → 0**

---

# **Brute Force Approach (Very Slow – O(n²))**

1. Generate all subarrays `nums[i..j]`.
2. For each subarray, count how many odd numbers it contains.
3. If the count equals `k`, increment the answer.

```cpp
int count = 0;
for (int i = 0; i < n; i++) {
    int oddCount = 0;
    for (int j = i; j < n; j++) {
        if (nums[j] % 2 == 1)
            oddCount++;
        if (oddCount == k)
            count++;
    }
}
```

**Why it's slow:**

* There are O(n²) subarrays.
* Will TLE for large inputs.

So we need an optimized approach.

---

# **Optimized Approach – Sliding Window with `atMost` Trick**

### **Core Formula**

```
Nice subarrays with exactly k odds
= atMost(k) − atMost(k − 1)
```

---

## **Key Reduction (Important Insight)**

Instead of counting odd numbers directly in every subarray:

* Treat **odd numbers as `1`**
* Treat **even numbers as `0`**

Now the problem becomes:

> **Count subarrays with sum = k**

Which is the same as **Binary Subarrays With Sum**.

---

# **How `atMost(k)` Works**

We count subarrays that contain **at most `k` odd numbers**.

Using a sliding window `[left..right]`:

1. Expand `right`
2. Add `1` if `nums[right]` is odd
3. If odd count exceeds `k`, shrink from the left
4. Add `(right - left + 1)` to the result

---

# **Code with Meaningful Variable Names**

```cpp
class Solution {
public:
    int atMost(vector<int>& nums, int k) {
        if (k < 0) return 0;

        int left = 0;
        int oddCount = 0;
        int totalSubarrays = 0;

        for (int right = 0; right < nums.size(); right++) {
            oddCount += (nums[right] % 2);  // odd → 1, even → 0

            while (oddCount > k) {
                oddCount -= (nums[left] % 2);
                left++;
            }

            totalSubarrays += (right - left + 1);
        }

        return totalSubarrays;
    }

    int numberOfSubarrays(vector<int>& nums, int k) {
        return atMost(nums, k) - atMost(nums, k - 1);
    }
};
```

---

# **Step-by-Step Explanation**

### **1. Expand the right pointer**

* Add `1` if `nums[right]` is odd
* Keep track of `oddCount`

### **2. Shrink the window if odd count exceeds `k`**

* Move `left` forward
* Subtract `1` if `nums[left]` was odd

### **3. Count valid subarrays**

For each `right`, all subarrays:

```
[left..right], [left+1..right], ..., [right..right]
```

have **at most `k` odd numbers**

Count added:

```
right - left + 1
```

---

# **Why Do We Use `atMost(k) − atMost(k − 1)`?**

* `atMost(k)` counts subarrays with:

  ```
  0, 1, 2, ..., k odds
  ```
* `atMost(k - 1)` counts subarrays with:

  ```
  0, 1, 2, ..., k - 1 odds
  ```

Subtracting removes all cases with fewer odds, leaving:

```
exactly k odds
```

---

# **Dry Run (Short Example)**

`nums = [1,1,2,1,1]`, `k = 3`

Odd mapping:

```
[1, 1, 0, 1, 1]
```

Valid nice subarrays:

* `[1,1,2,1]`
* `[1,2,1,1]`

Output = **2**

Using formula:

```
atMost(3) − atMost(2) = 2
```

---

# **Time and Space Complexity**

* **Time:** O(n)
  Each pointer moves at most `n` times.
* **Space:** O(1)
  Only integer variables are used.

---

## **Key Interview Takeaway**

> ❝ Nice Subarrays is just Binary Subarray Sum in disguise.
> Map odd → 1, even → 0, then apply
> `exact = atMost(k) − atMost(k − 1)` ❞
