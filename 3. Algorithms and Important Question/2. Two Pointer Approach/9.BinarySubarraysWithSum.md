# **930. Binary Subarrays With Sum â€“ Notes**

---

## **Problem Summary**

We are given a **binary array** `nums` (containing only `0` and `1`) and an integer `goal`.

We must count the number of **contiguous subarrays whose sum is exactly equal to `goal`**.

**Key idea:**
Because the array is binary, we can use a **sliding window + prefix idea (`atMost`)** to efficiently count subarrays.

---

# **Brute Force Approach (Very Slow â€“ O(nÂ²))**

1. Fix a starting index `i`.
2. For every `j â‰¥ i`, compute the sum of subarray `nums[i..j]`.
3. If the sum equals `goal`, increment the count.

```cpp
int count = 0;
for (int i = 0; i < n; i++) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += nums[j];
        if (sum == goal)
            count++;
    }
}
```

**Why it's slow:**

* There are O(nÂ²) subarrays.
* This will TLE for large `n` (up to 30,000).

So we need an optimized approach.

---

# **Optimized Approach â€“ Sliding Window with `atMost` Trick**

### **Core Formula**

```
Subarrays with sum == goal
= atMost(goal) âˆ’ atMost(goal âˆ’ 1)
```

---

## **Why This Works (Important Insight)**

* `atMost(x)` = number of subarrays whose sum is **â‰¤ x**
* If we subtract:

  ```
  (subarrays with sum â‰¤ goal)
  ```

âˆ’ (subarrays with sum â‰¤ goal âˆ’ 1)

```

ðŸ‘‰ we are left with subarrays whose sum is **exactly equal to `goal`**.

This trick works **only because the array is binary** (non-negative numbers).

---

# **How `atMost(goal)` Works**

We use a sliding window `[left..right]`:

1. Expand `right`, add `nums[right]` to `currentSum`
2. If `currentSum > goal`, shrink from the left
3. For every valid window, add:

```

(right - left + 1)

````

These are all subarrays ending at `right` with sum â‰¤ goal.

---

# **Code with Meaningful Variable Names**

```cpp
class Solution {
public:
    int countSubarraysWithSumAtMost(vector<int>& nums, int goal) {
        if (goal < 0) return 0;

        int left = 0;
        int currentSum = 0;
        int count = 0;

        for (int right = 0; right < nums.size(); right++) {
            currentSum += nums[right];

            while (currentSum > goal) {
                currentSum -= nums[left];
                left++;
            }

            count += (right - left + 1);
        }

        return count;
    }

    int numSubarraysWithSum(vector<int>& nums, int goal) {
        return countSubarraysWithSumAtMost(nums, goal) -
               countSubarraysWithSumAtMost(nums, goal - 1);
    }
};
````

---

# **Step-by-Step Explanation**

### **1. Expand the right pointer**

* Add `nums[right]` to `currentSum`

### **2. Shrink the window if sum exceeds goal**

* Move `left` forward
* Subtract `nums[left]` from `currentSum`

### **3. Count valid subarrays**

For a fixed `right`, all subarrays:

```
[left..right], [left+1..right], ..., [right..right]
```

have sum â‰¤ goal

Number of such subarrays:

```
right - left + 1
```

---

# **Why Do We Subtract `atMost(goal - 1)`?**

Because:

* `atMost(goal)` counts subarrays with sum:

  ```
  0, 1, 2, ..., goal
  ```
* `atMost(goal - 1)` counts:

  ```
  0, 1, 2, ..., goal - 1
  ```

Subtracting removes all smaller sums, leaving **only sum = goal**.

---

# **Dry Run (Short Example)**

`nums = [1,0,1,0,1]`, `goal = 2`

### `atMost(2)` â†’ 14

### `atMost(1)` â†’ 10

```
Exact sum = 14 - 10 = 4
```

Valid subarrays:

* [1,0,1]
* [1,0,1,0]
* [0,1,0,1]
* [1,0,1]

Answer = **4**

---

# **Time and Space Complexity**

* **Time:** O(n)
  Each pointer moves at most `n` times.
* **Space:** O(1)
  Only integer variables are used.

---

## **Key Interview Takeaway**

> Exact subarray sum problems with **binary or non-negative arrays**
> are best solved using:
>
> ```
> exact = atMost(x) âˆ’ atMost(x âˆ’ 1)
> ```
