# ## Problem Statement

You are given:

* A string `s` consisting of lowercase letters.
* An integer `k`.

Return the **length of the longest substring** that contains **exactly `k` distinct characters**.

If no such substring exists, return `-1`.

---

# ## Thought Process

### **1. What is the problem asking?**

We want the **longest continuous substring** (subarray) where the number of **distinct characters** is exactly `k`.

This is almost identical to the "Fruit Into Baskets" problem, except:

* In the fruit problem → **at most 2 distinct**
* Here → **exactly k distinct**

---

### **2. First Idea (Brute Force)**

Try every possible substring, count how many unique characters it has.

But checking uniqueness repeatedly is expensive.

A better brute force idea is:

1. Pick a starting index `i`.
2. Expand `j` to the right.
3. Maintain a frequency map for the substring `s[i…j]`.
4. Stop when the number of unique characters **exceeds k**.
5. Only update the result if we have **exactly k** distinct chars.

This is still quadratic, but it intelligently stops expanding early.

---

### **3. Data Structure Thoughts**

| Purpose                        | Data Structure                       | Reason                                        |
| ------------------------------ | ------------------------------------ | --------------------------------------------- |
| Track counts inside substring  | `unordered_map<char, int>`           | Fast counting, tells number of distinct chars |
| Brute force frequency tracking | Same map                             | Needed to know unique count                   |
| Sliding window                 | Two integer pointers `left`, `right` | Efficient expansion/shrinking                 |

---

### **4. Why Sliding Window?**

This fits the classic pattern:

* “Longest substring”
* “With exactly / at most K distinct characters”
* “Must be contiguous”

→ **Sliding window is always the optimal approach**.

---

# ## Brute Force Approach (O(n²))

### **Idea**

For every starting point:

* Expand until unique characters exceed `k`.
* Track the longest substring with **exactly k** distinct characters.

### **Complexity**

* **Time:** `O(n²)` worst case
* **Space:** `O(k)` for frequency map

### Brute Force Code

```cpp
class Solution {
public:
    int longestKSubstr(string s, int k) {
        int n = s.size();
        int maxLen = -1;

        for (int i = 0; i < n; i++) {
            unordered_map<char, int> freq;

            for (int j = i; j < n; j++) {
                freq[s[j]]++;

                if (freq.size() == k) {
                    maxLen = max(maxLen, j - i + 1);
                }
                else if (freq.size() > k) {
                    break;
                }
            }
        }

        return maxLen;
    }
};
```

---

# ## Intuition

We want the longest segment where:

```
# of distinct characters == k
```

Brute force grows every substring until it breaks.

But we can do better:

Instead of “start a new substring every time,” we can slide one window over the string and adjust it efficiently whenever the distinct character count becomes invalid.

---

# ## Optimal Approach (Sliding Window)

### **Technique**

Use a sliding window that always maintains:

```
Distinct characters <= k
```

But remember:

* If window has **less than k** → invalid but can still grow.
* If window has **more than k** → shrink from the left.
* If window has **exactly k** → candidate answer.

### **Algorithm**

1. `left = 0`
2. Create a frequency map `freq`.
3. Iterate with `right` over the string:

   * Add `s[right]` to the map.
4. If map size > k:

   * Shrink using `left`
   * Remove characters whose count becomes 0
5. If map size == k:

   * Update maximum length

---

# ## Complexity

* **Time:** `O(n)`
* **Space:** `O(k)` for the map

---

# ## Optimal Code (O(n) Sliding Window)

```cpp
class Solution {
public:
    int longestKSubstr(string s, int k) {
        unordered_map<char, int> freq;
        int left = 0, maxLen = -1;

        for (int right = 0; right < s.size(); right++) {
            freq[s[right]]++;

            // if more than k, shrink window
            while (freq.size() > k) {
                freq[s[left]]--;
                if (freq[s[left]] == 0)
                    freq.erase(s[left]);
                left++;
            }

            // valid window with EXACTLY k uniques
            if (freq.size() == k)
                maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```

---

# ## Key Pattern to Remember

* **Longest substring with EXACTLY K distinct characters**
  → sliding window, adjust based on when window becomes invalid

* **Longest substring with AT MOST K distinct characters**
  → sliding window, only shrink when > K

* **Longest substring with NO REPEATING characters**
  → sliding window, shrink only when duplicate appears

* **Fruit Into Baskets**
  → same as “at most 2 distinct characters”

---
