
# Problem Statement

You are given:

* A string `s` containing uppercase English letters.
* An integer `k`.

You are allowed to **replace at most `k` characters** in the string.

Return the **length of the longest substring** that can be transformed into a substring consisting of a **single repeated character** by performing **at most `k` replacements**.

---

# Thought Process

### **1. What is the problem asking?**

We want the **longest continuous substring** where:

```
By changing ≤ k characters
→ the entire substring becomes the same letter.
```

This is a classic “longest substring under a constraint” problem.

Key observation:

* For any substring `s[i...j]`
  → the number of replacements needed
  = `window_length – max_frequency_character_in_window`

---

### **2. First Idea (Brute Force)**

Try every possible substring.

For each substring:

1. Track frequency of each character.
2. Find the **most frequent** character.
3. Compute replacements required:

   ```
   replace = window_length – maxFreq
   ```
4. If `replace ≤ k`, the substring is valid.

This checks all substrings ⇒ quadratic time.

---

### **3. Data Structure Thoughts**

| Purpose                                   | Data Structure               | Why?                                   |
| ----------------------------------------- | ---------------------------- | -------------------------------------- |
| Track frequency inside current substring  | `vector<int>` or `map`       | Fast updates, needed for maxFreq       |
| Sliding window version frequency tracking | `unordered_map<char, int>`   | Efficient for expanding windows        |
| Window management                         | Two pointers `left`, `right` | Classic for longest substring problems |

---

### **4. Why Sliding Window?**

This problem matches the standard pattern:

* Longest substring
* Condition based on counts inside window
* Window must remain contiguous

Sliding window gives optimal performance because:

* The window only ever moves forward.
* Frequency counts can be updated in constant time.
* We never recompute full substring information from scratch.

---

# ## Brute Force Approach (O(n²))

### **Idea**

Fix each starting index `i`, expand the end index `j` step-by-step:

1. Maintain a frequency array of size 26 for characters `'A'–'Z'`.
2. After each expansion:

   * Compute `maxFreq` (most common character in current substring).
   * Compute replacements needed.
3. If replacements ≤ `k`, update answer.

### **Complexity**

* **Time:** `O(n²)`
  Every `i` expands to all `j`.
* **Space:** `O(1)`
  Just a frequency array of size 26.

---

### Brute Force Code

```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        int maxLength = 0;

        for (int i = 0; i < s.length(); i++) {
            vector<int> freq(26, 0);
            int maxFreq = 0;

            for (int j = i; j < s.length(); j++) {
                freq[s[j] - 'A']++;
                maxFreq = max(maxFreq, freq[s[j] - 'A']);

                int windowLength = j - i + 1;
                int replace = windowLength - maxFreq;

                if (replace <= k) {
                    maxLength = max(maxLength, windowLength);
                }
            }
        }

        return maxLength;
    }
};
```

---

# ## Intuition

We always try to make the substring uniform by converting all characters into the **most frequent character** in that window.

So inside any window:

```
replacements_needed = window_size – most_frequent_char_count
```

If replacements_needed ≤ k → window is valid.

The brute force approach checks this for all substrings.

But we can improve performance drastically using a sliding window.

---

# ## Optimal Approach (Sliding Window)

### **Technique**

Maintain a window with these rules:

1. Track frequency of characters in the window.
2. Track `max_freq` = count of the most frequent character.
3. The window is *valid* when:

   ```
   (window_size – max_freq) ≤ k
   ```
4. If window becomes invalid, shrink it from the left.
5. Update the maximum window length whenever valid.

Important Note:

* `max_freq` never needs to decrease.
* Even if the window shrinks, the existing `max_freq` still gives a safe upper bound.
* This allows the algorithm to remain O(n).

---

### **Algorithm Summary**

1. Initialise:

   * `left = 0`
   * `freq` map
   * `max_freq = 0`
2. Move `right` from `0` to `n−1`:

   * Increase frequency of `s[right]`
   * Update `max_freq`
3. If window invalid:

   * shrink from left until valid again
4. Update max window length

---

# ## Complexity

* **Time:** `O(n)`
  Every character is visited at most twice.
* **Space:** `O(1)`
  Only 26 uppercase characters.

---

# ## Optimal Code (O(n) Sliding Window)

```cpp
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> freq;

        int left = 0;
        int max_freq = 0;
        int max_len = 0;

        for (int right = 0; right < s.length(); right++) {

            freq[s[right]]++;
            max_freq = max(max_freq, freq[s[right]]);

            while ((right - left + 1) - max_freq > k) {
                freq[s[left]]--;
                left++;
            }

            max_len = max(max_len, right - left + 1);
        }

        return max_len;
    }
};
```

---

# ## Key Pattern to Remember

* “Longest substring under a constraint” → almost always a sliding window.
* Maintain:

  * window size
  * frequency map
  * most frequent character

General formula for this problem:

```
window_valid ⇔ window_size – max_freq ≤ k
```

This same pattern appears in:

* Longest substring without repeating characters
* Longest substring with at most K distinct characters
* Fruit Into Baskets
* Replace K characters to make substring uniform

---


