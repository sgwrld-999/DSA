# **1358. Number of Substrings Containing All Three Characters – Notes**

## **Problem Summary**

We are given a string `s` made up of only characters `'a'`, `'b'`, and `'c'`.
We must count how many substrings contain **at least one occurrence of all three characters**.

**Key idea:**
We must find substrings that have `'a'`, `'b'`, and `'c'` inside them.
This is a **sliding window** problem.

---

# **Brute Force Approach (Very Slow – O(n³) or O(n²))**

1. Generate every substring `s[i..j]`.
2. For each substring, check if it contains `'a'`, `'b'`, and `'c'`.
3. Count valid substrings.

**Why it's slow:**
There can be up to (10^{10}) substrings for n = 50,000.
Checking each is impossible.

So we need an optimized sliding window approach.

---

# **Optimized Approach – Sliding Window (Two Pointers)**

**Goal:**
Use a window `[left..right]` that always tracks whether it contains `'a'`, `'b'`, `'c'`.

### **Key Observations**

1. If a window `[left..right]` is valid (contains all 3 chars),
   then **every window ending at positions `right, right+1, ..., n-1`** is also valid.

   Example:
   If substring `s[left..right]` is valid, and we extend right to the end,
   those substrings also have all 3 chars.

2. This creates a formula:

   ```
   contribution = (n - right)
   ```

   These are all valid substring endings.

3. We then shrink the window from the left until it becomes invalid.

---

# **Code with Meaningful Variable Names**

```cpp
class Solution {
public:
    int numberOfSubstrings(string s) {
        int n = s.size();
        int left = 0, right = 0;
        int countSubstrings = 0;
        unordered_map<char,int> freq;

        while (right < n) {
            freq[s[right]]++;

            // window becomes valid when it has all 3 distinct chars
            while (freq.size() == 3) {

                countSubstrings += (n - right);

                freq[s[left]]--;
                if (freq[s[left]] == 0)
                    freq.erase(s[left]);
                
                left++;
            }

            right++;
        }

        return countSubstrings;
    }
};
```

---

# **Step-by-Step Explanation**

### **1. Expand the right pointer**

* Add characters to the window.
* Increase frequency count of `s[right]`.

### **2. When the window has all 3 characters**

`freq.size() == 3`

Now count valid substrings:

```
All substrings starting at "left" and ending at right, right+1, ..., n-1
```

So we add:

```
n - right
```

### **3. Shrink the window**

* Move `left` forward.
* Decrease frequency.
* If any frequency becomes 0, erase that character.
* Continue until window becomes invalid again.

---

# **Why Do We Add (n - right)?**

Because:

If `s[left..right]` is valid, then:

* `s[left..right]`
* `s[left..right+1]`
* `s[left..right+2]`
* …
* `s[left..n-1]`

are **all valid** substrings.

The number of such substrings is exactly:

```
n - right
```

---

# **Dry Run (Short Example)**

Let `s = "aaacb"`
Expected output = 3

Valid substrings:

* "aaacb"
* "aacb"
* "acb"

Walkthrough:

| left           | right        | window | valid? | add                   |
| -------------- | ------------ | ------ | ------ | --------------------- |
| 0              | 0            | a      | no     | 0                     |
| 0              | 1            | aa     | no     | 0                     |
| 0              | 2            | aaa    | no     | 0                     |
| 0              | 3            | aaac   | no     | 0                     |
| 0              | 4            | aaacb  | yes    | n - right = 5 - 4 = 1 |
| left moves → 1 | window: aacb | yes    | add 1  |                       |
| left moves → 2 | window: acb  | yes    | add 1  |                       |
| left moves → 3 | window: cb   | no     | stop   |                       |

Total = 3.

---

# **Time and Space Complexity**

* **Time:** O(n)
  Each pointer moves at most n steps.
* **Space:** O(1)
  Map stores only characters `'a'`, `'b'`, `'c'`.

---
