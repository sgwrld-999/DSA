# **992. Subarrays with K Different Integers – Notes**

---

## **Problem Summary**

We are given an integer array `nums` and an integer `k`.

We must count the number of **contiguous subarrays that contain exactly `k` distinct integers**.

**Key idea:**
This problem is solved using the **`atMost` sliding window technique**, similar to:

* Binary Subarrays With Sum
* Count Number of Nice Subarrays

---

# **Brute Force Approach (Very Slow – O(n²))**

1. Generate all subarrays `nums[i..j]`.
2. For each subarray, count the number of distinct elements using a set.
3. If the count equals `k`, increment the answer.

```cpp
int count = 0;
for (int i = 0; i < n; i++) {
    unordered_set<int> distinct;
    for (int j = i; j < n; j++) {
        distinct.insert(nums[j]);
        if (distinct.size() == k)
            count++;
    }
}
```

**Why it's slow:**

* There are O(n²) subarrays.
* Each subarray requires set operations.
* Will TLE for large inputs.

So we need an optimized approach.

---

# **Optimized Approach – Sliding Window with `atMost` Trick**

### **Core Formula**

```
Subarrays with exactly k distinct
= atMost(k) − atMost(k − 1)
```

---

## **Key Observation (Very Important)**

* `atMost(k)` counts subarrays that contain **at most `k` distinct elements**
* `atMost(k − 1)` counts subarrays that contain **at most `k − 1` distinct elements**

Subtracting removes all subarrays with fewer than `k` distinct elements, leaving:

```
exactly k distinct elements
```

---

# **How `atMost(k)` Works**

We maintain a sliding window `[left..right]` such that:

* The window always has **at most `k` distinct elements**
* We use a frequency map to track occurrences

---

# **Code with Meaningful Variable Names**

```cpp
class Solution {
public:
    int countSubarraysWithAtMostKDistinct(vector<int>& nums, int k) {
        int left = 0;
        int totalSubarrays = 0;
        unordered_map<int, int> frequency;

        for (int right = 0; right < nums.size(); right++) {
            frequency[nums[right]]++;

            while (frequency.size() > k) {
                frequency[nums[left]]--;
                if (frequency[nums[left]] == 0)
                    frequency.erase(nums[left]);
                left++;
            }

            totalSubarrays += (right - left + 1);
        }

        return totalSubarrays;
    }

    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return countSubarraysWithAtMostKDistinct(nums, k) -
               countSubarraysWithAtMostKDistinct(nums, k - 1);
    }
};
```

---

# **Step-by-Step Explanation**

### **1. Expand the right pointer**

* Add `nums[right]` to the frequency map
* Track how many distinct elements exist in the window

### **2. Shrink the window if distinct count exceeds `k`**

* Move `left` forward
* Decrease frequency of `nums[left]`
* Remove it from the map if frequency becomes 0

### **3. Count valid subarrays**

For a fixed `right`, all subarrays:

```
[left..right], [left+1..right], ..., [right..right]
```

contain **at most `k` distinct elements**

Count added:

```
right - left + 1
```

---

# **Why Do We Add `(right - left + 1)`?**

Because all subarrays ending at `right` and starting anywhere from `left` to `right`
are valid when the window satisfies the constraint.

---

# **Dry Run (Short Example)**

`nums = [1,2,1,2,3]`, `k = 2`

### `atMost(2)` counts:

All subarrays with ≤ 2 distinct elements

### `atMost(1)` counts:

All subarrays with ≤ 1 distinct element

```
exactly 2 distinct = atMost(2) − atMost(1) = 7
```

Valid subarrays:

* `[1,2]`
* `[2,1]`
* `[1,2]`
* `[2,1,2]`
* `[1,2,1]`
* `[1,2,3]`
* `[2,3]`

---

# **Time and Space Complexity**

* **Time:** O(n)
  Each pointer moves at most `n` times.
* **Space:** O(k)
  Frequency map stores at most `k` elements.

---

## **Key Interview Takeaway**

> ❝ Exact constraint problems with **non-negative window expansion**
> are best solved using:
>
> ```
> exact = atMost(x) − atMost(x − 1)
> ```
>
> This applies to:
>
> * Binary Subarray Sum
> * Nice Subarrays
> * K Distinct Integers
