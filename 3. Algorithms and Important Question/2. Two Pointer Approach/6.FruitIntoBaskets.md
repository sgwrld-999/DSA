# ## Problem Statement

You are given an integer array `fruits` where `fruits[i]` is the type of fruit produced by the (i^{th}) tree.

Rules:

1. You have **two baskets**.
2. Each basket can hold **only one type of fruit**, but **unlimited quantity**.
3. You may **start at any tree**, and must pick **exactly one fruit from every tree** while moving **only to the right**.
4. The moment you reach a tree whose fruit does **not fit** in your two baskets, you must **stop picking**.

Return the **maximum number of fruits** you can collect.

---

# ## Thought Process

### **1. What is the problem asking?**

We want the **longest continuous sequence** (subarray) where there are **at most two distinct fruit types**.

The key line:

> “Starting from any tree … pick from every tree while moving to the right … stop when fruit cannot fit.”

This implies the answer must be a **subarray** (contiguous segment).

---

### **2. First idea (Brute Force)**

Try **all possible pairs** of fruit types (because we have 2 baskets), and count how many fruits we can pick if only those two types are allowed.

Limitations:

* Slow because there may be many fruit types.
* For each pair, we iterate through the entire array.

---

### **3. Improve thought process**

We don’t care about non-contiguous positions. The problem always deals with **contiguous** trees → suggests **subarray techniques**.

Whenever you see:

* “longest subarray”
* “at most K distinct”
* “continuous stretching until broken”

→ **Sliding window** is the natural fit.

---

### **4. Sliding Window Idea**

As we walk through the array:

* Expand the window to the right.
* Track how many types of fruit are inside the window.
* If we exceed 2 types → shrink window from the left.

### Invariant:

**Window `[left … right]` always contains ≤ 2 distinct fruits.**

---

### **5. Choosing Data Structures**

| Purpose                                 | Data Structure               | Why                                                        |
| --------------------------------------- | ---------------------------- | ---------------------------------------------------------- |
| Track fruit types & count inside window | `unordered_map<int, int>`    | O(1) insert/erase, keeps frequency, size() tells #distinct |
| Sliding window bounds                   | Two integers `left`, `right` | Efficient pointer movement                                 |
| Track unique fruits (brute force)       | `set<int>`                   | Automatically stores only unique types                     |
| List of pairs (brute force)             | `vector<pair<int,int>>`      | Easy to generate all (a, b) combinations                   |

---

# ## Brute Force Approach

### **Idea:**

Choose every possible pair `(a, b)` of fruit types and count the longest segment that contains only those two types.

### **Steps:**

1. Extract all **unique fruit types**.
2. Generate **all pairs** of types → because 2 baskets.
3. For each pair, scan the array from left to right:

   * Count the streak while the fruit belongs to {a, b}.
   * Stop when a fruit of a third type appears.
4. Track the maximum.

---

### **Complexity**

* **Time:**
  (O(k^2 \cdot n))
  where `k` = unique fruit types, `n` = array size.

* **Space:**
  (O(k)) for unique type storage.

---

### Brute Force Code (O(k² × n))

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int n = fruits.size();
        set<int> uniqueFruits(fruits.begin(), fruits.end());

        vector<int> types(uniqueFruits.begin(), uniqueFruits.end());
        vector<pair<int, int>> pairs;

        // generate all unique pairs
        for (int i = 0; i < types.size(); i++)
            for (int j = i + 1; j < types.size(); j++)
                pairs.push_back({types[i], types[j]});

        int maxLen = 0;

        // for each pair, simulate picking
        for (auto &p : pairs) {
            int a = p.first, b = p.second;
            int curr = 0;

            for (int f : fruits) {
                if (f == a || f == b) {
                    curr++;
                    maxLen = max(maxLen, curr);
                } else {
                    curr = 0;
                }
            }
        }

        return maxLen;
    }
};
```

---

# ## Intuition

We want the longest continuous portion of the array that contains **no more than two fruit types**.

Brute force inspects all possible type pairs and counts what continuous stretch we get.

But this is slow.
We need a technique that:

* Grows the segment while valid
* Shrinks the segment when invalid
* Tracks the maximum length efficiently

This is exactly what a **sliding window** does.

---

# ## Approach (Optimized Sliding Window)

### **Key Insight**

We need the **longest subarray with at most 2 distinct numbers**.

### **Algorithm**

1. Use `left` and `right` pointers for the window.
2. Use a hash map to store `{fruit → count in window}`.
3. Move `right` forward:

   * Add `fruits[right]` to the map.
4. If map size > 2 (invalid):

   * Move `left` forward, decreasing counts.
   * Remove keys with 0 count.
5. At each valid window, compute:

   ```
   maxLen = max(maxLen, right - left + 1)
   ```

This ensures the window always contains **at most 2 distinct fruits**.

---

# ## Complexity

* **Time:** `O(n)`
  Each element is added/removed from the window at most once.

* **Space:** `O(1)`
  Map can hold at most 3 keys temporarily (before shrinking).

---

# ## Code (Optimized O(n))

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> count;
        int left = 0, maxLen = 0;

        for (int right = 0; right < fruits.size(); right++) {
            count[fruits[right]]++;

            // if more than 2 types, shrink from left
            while (count.size() > 2) {
                count[fruits[left]]--;
                if (count[fruits[left]] == 0)
                    count.erase(fruits[left]);
                left++;
            }

            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```

---

# ## Key Pattern to Remember

Whenever a problem asks for:

* “**Longest subarray** …”
* “With **at most K distinct items** …”
* “Stop when a rule is **violated** …”
* “Pick continuously from left to right …”

→ Use **Sliding Window + Hash Map**.

This solves a large class of interval problems efficiently.

---

