# **Count Nodes in a Complete Binary Tree – Notes**

## **1. Problem Definition**

Given the root of a **complete binary tree**, the task is to count the total number of nodes efficiently.

### **What is a Complete Binary Tree?**

A binary tree where:

1. Every level is completely filled **except possibly the last**.
2. In the last level, nodes are filled **from left to right**, without gaps.

### **Important Points**

* A naive counting method (DFS/BFS) takes **O(n)** time.
* A complete tree has special structure → allows faster counting.
* We can detect if a subtree is a **perfect tree**, where all levels are filled.

---

# **2. Core Idea**

We use the heights of:

* The **leftmost path**
* The **rightmost path**

from the same root.

### Why this works?

Because:

1. If both heights are equal → the subtree is a **perfect binary tree**.
2. If heights differ → the subtree is not perfect, so count recursively.

---

# **2.1 Key Observation (Added Section)**

### **How do leftHeight and rightHeight detect a perfect tree?**

* leftHeight = number of nodes while moving only left.
* rightHeight = number of nodes while moving only right.

For a **perfect binary tree**:

```
leftmost height == rightmost height
```

This means the subtree is shaped like this:

```
          o
       /     \
      o       o
    /  \     /  \
   o    o   o    o
```

Since every level is full, height from left edge = height from right edge.

### **Why is this useful?**

If a subtree is perfect:

\text{Node count} = 2^{\text{height}} - 1

This formula runs in **O(1)**.

So instead of traversing the subtree (which may have thousands of nodes),
we compute its size instantly.

### **Resulting Time Complexity**

Because at each level we either:

* compute heights (O(log n)), and
* go only one level deeper,

the overall time becomes:

O\left( (\log n)^2 \right)

Much faster than O(n).

---

# **3. Explanation of the Algorithm**

### **Step 1 — Base Case**

If the root is null → no nodes.

---

### **Step 2 — Compute Left Height and Right Height**

Move downward:

* Always going left for leftHeight
* Always going right for rightHeight

These give the depths of the extreme edges of the subtree.

---

### **Step 3 — Check if Subtree is Perfect**

If:

```
leftHeight == rightHeight
```

then the subtree is perfect.

So we return:

2^{\text{height}} - 1

This avoids recursion entirely.

---

### **Step 4 — If Not Perfect, Recurse on Children**

If heights differ, the subtree is not perfect.

So we count:

```
1 (root) 
+ nodes in left subtree  
+ nodes in right subtree
```

Recursively apply the same process.

---

# **4. Why This Algorithm Works**

A complete binary tree always has at least one perfect subtree.

By quickly identifying perfect subtrees, we skip large chunks of nodes and avoid traversing the whole tree.

This drastically improves speed:

* Only log n levels in height
* At each level we calculate heights in log n time

Hence:

O((\log n)^2)

---

# **5. Time and Space Complexity**

### **Time Complexity**

O((\log n)^2)

### **Space Complexity**

O(\log n)

(from recursive calls)

---

# **6. Final Code (with same logic and improved clarity)**

```cpp
class Solution {
private:
    int getLeftHeight(TreeNode* node) {
        int height = 0;
        while (node) {
            height++;
            node = node->left;
        }
        return height;
    }

    int getRightHeight(TreeNode* node) {
        int height = 0;
        while (node) {
            height++;
            node = node->right;
        }
        return height;
    }

public:
    int countNodes(TreeNode* root) {
        if (!root)
            return 0;

        int leftH = getLeftHeight(root);
        int rightH = getRightHeight(root);

        // Case 1: Perfect binary subtree
        if (leftH == rightH)
            return (1 << leftH) - 1;  // 2^height - 1

        // Case 2: Not perfect → split and count recursively
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

---

# **7. Dry Run (Added Section)**

Consider the following complete tree:

```
         1
       /   \
      2     3
     / \   /
    4   5 6
```

### **Call 1: countNodes(1)**

left height:

```
1 → 2 → 4 → null
height = 3
```

right height:

```
1 → 3 → null
height = 2
```

`lh != rh` → NOT perfect → recurse.

---

### **Call 2: countNodes(2)**

left height:

```
2 → 4 → null = 2
```

right height:

```
2 → 5 → null = 2
```

They are equal → subtree rooted at 2 is PERFECT.

Nodes in perfect tree of height 2:

```
(1 << 2) - 1 = 3
```

So subtree has: **3 nodes** (nodes 2,4,5)

---

### **Call 3: countNodes(3)**

left height:

```
3 → 6 → null = 2
```

right height:

```
3 → null = 1
```

Not equal → recurse.

---

### **Call 4: countNodes(6)**

left height = 1
right height = 1
equal → perfect subtree of height 1

```
(1 << 1) - 1 = 1
```

Node 6 only.

---

### **Call 5: countNodes(null)**

returns 0

---

### **Final Calculation**

```
countNodes(1) = 
1 (root)
+ countNodes(2)   // 3
+ countNodes(3)   // 1 (node 6)
= 1 + 3 + 1
= 5
```

Correct.

---
