## **Bottom View of Binary Tree**

**Problem Link:** [GeeksforGeeks](https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1)

-----

### **1. Problem Understanding**

We are given a binary tree. Imagine you are looking at the tree from **directly below**. You need to return the nodes that are visible from the bottom, ordered from **left to right**.

**The Coordinate System (Horizontal Distance - HD):**

  * The **Root** is at horizontal distance `0`.
  * Moving **Left** subtracts 1 (`hd - 1`).
  * Moving **Right** adds 1 (`hd + 1`).

**Visibility Rule:**

  * If multiple nodes occupy the same Horizontal Distance (stacking vertically), the **bottom-most** node is the one visible.
  * If multiple nodes are at the same bottom-most level, the one that appears **later** in the level order traversal (the right-most one) is usually considered the "visible" one.

-----

### **2. Intuition (Top View vs. Bottom View)**

  * **Similarity:** Like Top View, we use **Horizontal Distance** to track vertical lines and **BFS (Level Order Traversal)** to traverse layer by layer.
  * **The Difference:**
      * **Top View:** We only care about the *first* node we see at a specific HD.
      * **Bottom View:** We care about the *last* node we see at a specific HD.
  * **Why BFS?** As we traverse down the tree, we encounter nodes at lower levels later. By **constantly overwriting** the map entry for a specific HD, the value remaining in the map at the end will naturally be the node from the deepest level.

-----

### **3. Algorithm**

1.  **Initialization:**
      * Create a `queue` for BFS storing pairs: `{Node*, horizontal_distance}`.
      * Create a `map<int, int>` called `bottomNode`. Key = HD, Value = Node Data.
2.  **BFS Process:**
      * Push `{root, 0}` to the queue.
      * While the queue is not empty:
          * Pop the front element (`curr` node and `hd`).
          * **Crucial Logic:** Update the map `bottomNode[hd] = curr->data`. **Always overwrite**. This ensures that as we go deeper, the newer (lower) nodes replace the older (higher) nodes at the same horizontal position.
          * Push children:
              * Left child: `hd - 1`
              * Right child: `hd + 1`
3.  **Format Output:** Iterate through the map (which is sorted by HD) and collect values into a vector.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **O(N log N)**
      * We visit every node once ($N$).
      * Insertion/Update in a C++ ordered `map` takes $O(\log K)$ where $K$ is the width of the tree.
  * **Space Complexity:** **O(N)**
      * Queue stores up to width of the tree. Map stores one entry per horizontal distance.

-----

### **5. Code**

```cpp
/*
struct Node
{
    int data;
    Node* left;
    Node* right;
};
*/

class Solution {
public:
    vector<int> bottomView(Node *root) {
        if (!root) return {};
        
        // Map to store <Horizontal Distance, Node Data>
        // Keys are sorted automatically (-2, -1, 0, 1...)
        map<int, int> bottomNode;
        
        // Queue for BFS: {Node pointer, Horizontal Distance}
        queue<pair<Node*, int>> q;
        
        q.push({root, 0});
        
        while (!q.empty()) {
            auto p = q.front();
            q.pop();
            
            Node* curr = p.first;
            int hd = p.second;
            
            // CORE LOGIC FOR BOTTOM VIEW:
            // Always overwrite the value at this HD.
            // Since BFS goes level-by-level, the last value written 
            // will be the bottom-most node.
            bottomNode[hd] = curr->data;
            
            if (curr->left)  q.push({curr->left, hd - 1});
            if (curr->right) q.push({curr->right, hd + 1});
        }
        
        // Extract values from the map
        vector<int> ans;
        for (auto& x : bottomNode) {
            ans.push_back(x.second);
        }
        
        return ans;
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
       20
      /  \
    8     22
   / \      \
  5   3      25
     / \
   10   14
```

**Execution Trace:**

1.  **Pop 20 (hd 0):** `map[0] = 20`. Children: `8 (hd -1)`, `22 (hd 1)`.
2.  **Pop 8 (hd -1):** `map[-1] = 8`. Children: `5 (hd -2)`, `3 (hd 0)`.
3.  **Pop 22 (hd 1):** `map[1] = 22`. Child: `25 (hd 2)`.
4.  **Pop 5 (hd -2):** `map[-2] = 5`.
5.  **Pop 3 (hd 0):** `map[0] = 3`. **(Overwrites 20)**. *Node 3 is lower than 20.* Children: `10 (hd -1)`, `14 (hd 1)`.
6.  **Pop 25 (hd 2):** `map[2] = 25`.
7.  **Pop 10 (hd -1):** `map[-1] = 10`. **(Overwrites 8)**.
8.  **Pop 14 (hd 1):** `map[1] = 14`. **(Overwrites 22)**.

**Final Map State:**
`{-2: 5, -1: 10, 0: 3, 1: 14, 2: 25}`

**Output:** `[5, 10, 3, 14, 25]`

-----

### **7. Key Takeaways**

  * **Top View vs Bottom View:**
      * **Top View:** `if (map.find(hd) == map.end()) map[hd] = val;` (Keep First)
      * **Bottom View:** `map[hd] = val;` (Keep Last/Overwrite)
  * **BFS ensures depth:** Because we process the tree level by level, the overwriting logic guarantees that the final value in the map is from the deepest possible level for that horizontal distance.
  * **Ordering:** The `map` handles the left-to-right sorting of the horizontal distances automatically.

-----
