## **Same Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/same-tree/)

-----

### 1\. Problem Understanding

We are given:

  * Two pointers, `p` and `q`, to the roots of two separate binary trees.

We need to determine:

  * If the two trees are **identical**.

**Definition:**
Two binary trees are considered identical if they are **structurally the same** (i.e., they have the exact same shape) and all corresponding nodes have the **same value**.

-----

### 2\. When to Think of Recursion (for Trees)

This problem is a perfect fit for recursion because:

1.  **Hierarchical Structure:** The problem involves trees, which are inherently recursive data structures.
2.  **Self-Similarity:** The definition of "sameness" is recursive. Two trees are the same *if* their roots are the same, their left subtrees are the same, and their right subtrees are the same.
3.  **Base Case:** A clear base case exists: what does it mean for `NULL` (empty) trees to be the same?

-----

### 3\. Why This Recursive Approach?

We can define the sameness of two trees, `p` and `q`, by checking three conditions:

1.  **Base Cases (Handling `NULL`):**

      * If *both* `p` and `q` are `NULL`, they are identical. Return `true`.
      * If *one* of them is `NULL` and the other is not, they are different. Return `false`.
      * The code provided cleverly combines these two base cases into a single line: `if(p == nullptr || q == nullptr) { return (p == q); }`
          * If both are `NULL`, `(p == q)` is `true`.
          * If only one is `NULL`, `(p == q)` is `false`.

2.  **Recursive Step (If both are *not* `NULL`):**

      * We must check that the current nodes' values are equal (`p->val == q->val`).
      * We must *recursively* check that the left subtrees are identical (`isSameTree(p->left, q->left)`).
      * We must *recursively* check that the right subtrees are identical (`isSameTree(p->right, q->right)`).
      * Only if **all three** of these conditions are `true` can we say the trees are the same.

-----

### 4\. Algorithm (Step-by-Step)

1.  Define the function `isSameTree(p, q)`.
2.  **Handle Base Cases (Empty Nodes):**
      * Check if `p` is `NULL` or `q` is `NULL`.
      * If either is `NULL`, return the result of `(p == q)`. This simultaneously checks if *both* are `NULL` (returns `true`) or if just *one* is `NULL` (returns `false`).
3.  **Handle Recursive Step (Non-Empty Nodes):**
      * If the code proceeds past the base case, we know both `p` and `q` are valid, non-`NULL` nodes.
      * Return the logical AND (`&&`) of three checks:
        1.  Are the current values equal? `(p->val == q->val)`
        2.  Is the left subtree the same? `isSameTree(p->left, q->left)`
        3.  Is the right subtree the same? `isSameTree(p->right, q->right)`
      * If all three are `true`, the function returns `true`. If any one of them is `false`, it will "short-circuit" and return `false`.

-----

### 5\. Time Complexity

  * **O(N)**: In the worst case (the trees are identical or differ only at the very last node), we have to visit every single node in both trees.
  * Here, N is the **minimum** number of nodes in either tree, as the function will stop as soon as a difference is found.

-----

### 6\. Space Complexity

  * **O(H)**: The space complexity is determined by the maximum depth of the **recursion call stack**.
  * This is equal to the height (H) of the shallower tree.
      * **Best Case (Balanced Tree):** O(log N)
      * **Worst Case (Skewed Tree):** O(N)

-----

### 7\. Code

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x, left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        // Base case: If one or both nodes are NULL
        if(p == nullptr || q == nullptr){
            // Returns true if both are NULL, false if only one is NULL
            return (p == q); 
        }

        // Recursive step: Both nodes are non-NULL
        // 1. Check current values
        // 2. Recursively check left subtrees
        // 3. Recursively check right subtrees
        return (p -> val == q -> val) 
            && isSameTree(p->left, q->left) 
            && isSameTree(p->right, q->right);
    }
};
```

-----

### 8\. Dry Run Example

**Input:**

  * `p = [1, 2, 3]`
  * `q = [1, 2, 3]`

**Execution Trace:**

1.  `isSameTree(p[1], q[1])`:
      * `p` and `q` are not `NULL`.
      * `p->val == q->val`? (1 == 1) -\> `true`.
      * Call `isSameTree(p->left, q->left)` -\> `isSameTree(p[2], q[2])`:
          * `p` and `q` are not `NULL`.
          * `p->val == q->val`? (2 == 2) -\> `true`.
          * Call `isSameTree(p->left, q->left)` -\> `isSameTree(NULL, NULL)`:
              * `p` is `NULL`. Return `(p == q)` -\> `(NULL == NULL)` -\> `true`.
          * Call `isSameTree(p->right, q->right)` -\> `isSameTree(NULL, NULL)`:
              * `p` is `NULL`. Return `(p == q)` -\> `(NULL == NULL)` -\> `true`.
          * Return `(true && true && true)` -\> `true`.
      * Call `isSameTree(p->right, q->right)` -\> `isSameTree(p[3], q[3])`:
          * `p` and `q` are not `NULL`.
          * `p->val == q->val`? (3 == 3) -\> `true`.
          * Call `isSameTree(p->left, q->left)` -\> `isSameTree(NULL, NULL)` -\> `true`.
          * Call `isSameTree(p->right, q->right)` -\> `isSameTree(NULL, NULL)` -\> `true`.
          * Return `(true && true && true)` -\> `true`.
      * Return `(true && true && true)` -\> `true`.

âœ… **Final Answer:** **true**

-----

ðŸ“Œ **Key Takeaways**

  * This is a fundamental tree recursion pattern. The logic "check current, then check left, then check right" is extremely common.
  * Handling the `NULL` base cases is the most important part of any tree recursion. The `(p == q)` trick is a very clean and concise way to handle all `NULL` scenarios.
  * The `&&` (AND) operator ensures that the comparison stops and returns `false` as soon as *any* mismatch (value or structure) is found.