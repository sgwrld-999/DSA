## **Maximum Path Sum in a Binary Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/binary-tree-maximum-path-sum/)

-----

### 1\. Problem Understanding

We are given:

  * A pointer to the `root` of a binary tree, which can contain **positive or negative** node values.

We need to find:

  * The **maximum sum** of any **"path"**.

**Definition of Path:**
A path is a sequence of nodes connected by parent-child connections.

  * It must contain **at least one node**.
  * It can start at **any node** and end at **any node**.
  * It does **not** need to go through the root.
  * A node can appear at most once. This means the path can "split" at one node (go from a left child, to the parent, to a right child) but cannot branch multiple times.

-----

### 2\. Recursive Intuition

For any given `root` node, the maximum path can be one of three things:

1.  Entirely within the **left subtree**.
2.  Entirely within the **right subtree**.
3.  A path that **"splits"** at the `root`, using the `root` as the "peak". This path's sum would be `(best path from left) + (root->val) + (best path from right)`.

This hints at a recursive solution. We need a function that does two things simultaneously:

1.  **Updates a global `maxi` variable** every time it finds a new maximum "split" path.
2.  **Returns a value** to its parent, representing the *best one-way path* that the parent can choose to extend.

-----

### 3\. The "max(0, ...)" Trick (Handling Negatives)

This is the most important concept in this problem.

  * A path can choose to **stop** at any node.
  * If a recursive call to a child (e.g., `findPathSum(root->left, ...)` returns a **negative** sum (like -50), we should **not** include that path.
  * We would rather just take a sum of **0** (i.e., stop the path at the current `root` and don't go down that child's branch).
  * Therefore, when we get a result from a child, we always compute `max(0, child_path_sum)`. This "prunes" any negative-sum paths and ensures we only extend paths that have a positive contribution.

-----

### 4\. Approach: Optimal (O(N))

We use a single recursive helper function (a post-order traversal) that cleverly manages both the global maximum and the return value.

  * **Helper Function:** `findPathSum(root, &maxi)`
  * **Purpose 1: Updating `maxi` (The "Split" Path)**
      * At any node `root`, we calculate the maximum path sum that uses `root` as the *highest point* (the "split").
      * `split_sum = root->val + leftSum + rightSum`
      * We then update our overall answer: `maxi = max(maxi, split_sum)`
  * **Purpose 2: The Return Value (The "One-Way" Path)**
      * This function **cannot** return the `split_sum` to its parent. (A path cannot split twice).
      * It must return the maximum sum of a path that *ends* at `root` (or passes through it from *one* child). This is the path the parent can choose to extend.
      * `return root->val + max(leftSum, rightSum)`

-----

### 5\. Algorithm (Step-by-Step)

1.  Initialize `maxi = INT_MIN` in the main function. (The max sum could be a single negative node).
2.  Call the helper function `findPathSum(root, maxi)`.
3.  **Inside `findPathSum(root, &maxi)`:**
    1.  **Base Case:** If `root == nullptr`, return `0`. (A null node adds 0 to a path).
    2.  **Recursive Calls (Post-order):**
          * `int leftSum = max(0, findPathSum(root->left, maxi))`
          * `int rightSum = max(0, findPathSum(root->right, maxi))`
          * (Note: We use `max(0, ...)` here to ignore negative paths).
    3.  **Update Global Max:**
          * This is where we check the "split" path.
          * `maxi = max(maxi, root->val + leftSum + rightSum)`
    4.  **Return "One-Way" Path:**
          * Return the best path that can be extended by the parent node.
          * `return root->val + max(leftSum, rightSum)`
4.  The main function finally returns `maxi`.

-----

### 6\. Time Complexity

  * **O(N)**: We visit every node in the tree exactly once using a post-order traversal.

### 7\. Space Complexity

  * **O(H)**: The space is determined by the depth of the recursion call stack, which is equal to the height (H) of the tree.
  * In the worst case (a skewed tree), this can be O(N).
  * In the best case (a balanced tree), this is O(log N).

-----

### 8\. Code

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x, left(left), right(right) {}
 * };
 */
class Solution {
private:
    /**
     * This helper function does two things:
     * 1. Updates 'maxi' (by reference) with the max path sum found so far (which could be a "split" path).
     * 2. Returns the max path sum that starts (or passes through) 'root' and goes down *one side*.
     */
    int findPathSum(TreeNode* root, int &maxi){
        // Base case: A null node contributes 0 to the path sum.
        if(root == nullptr) return 0;

        // Recursively find the max path sum from left and right children.
        // Use max(0, ...) to "prune" paths with a negative sum.
        int leftSum = max(0, findPathSum(root->left, maxi));
        int rightSum = max(0, findPathSum(root->right, maxi));

        // Update the global maximum.
        // This is the "split" path: (left path) + (current node) + (right path)
        maxi = max(maxi, leftSum + rightSum + root->val);

        // Return the "one-way" path sum that the parent node can use.
        // We can only pick *one* side (left or right) to extend the path upwards.
        return (max(leftSum, rightSum) + root->val);
    }    
public:
    int maxPathSum(TreeNode* root) {
        // Initialize maxi to the smallest possible value.
        // We must use INT_MIN because the max path could be a single negative node (e.g., [-3]).
        int maxi = INT_MIN;
        
        // Call the helper. The return value of this call is not used,
        // as 'maxi' is updated by reference.
        findPathSum(root, maxi);
        
        return maxi;
    }
};
```

-----

### 9\. Dry Run Example

**Input Tree:** `[ -10, 9, 20, null, null, 15, 7 ]`

```
    -10
    / \
   9  20
      /  \
     15   7
```

**Execution Trace:**

  * `maxi = INT_MIN`
  * `findPathSum(-10, &maxi)`:
      * `findPathSum(9, &maxi)`:
          * `leftSum = max(0, findPathSum(NULL))` -\> `max(0, 0) = 0`
          * `rightSum = max(0, findPathSum(NULL))` -\> `max(0, 0) = 0`
          * `maxi = max(INT_MIN, 9 + 0 + 0) = 9`
          * Returns `9 + max(0, 0) = 9`
      * At `findPathSum(-10)`: `leftSum = max(0, 9) = 9`
      * `findPathSum(20, &maxi)`:
          * `findPathSum(15, &maxi)`:
              * `leftSum = max(0, 0) = 0`
              * `rightSum = max(0, 0) = 0`
              * `maxi = max(9, 15 + 0 + 0) = 15`
              * Returns `15 + max(0, 0) = 15`
          * `findPathSum(7, &maxi)`:
              * `leftSum = max(0, 0) = 0`
              * `rightSum = max(0, 0) = 0`
              * `maxi = max(15, 7 + 0 + 0) = 15`
              * Returns `7 + max(0, 0) = 7`
          * At `findPathSum(20)`:
              * `leftSum = max(0, 15) = 15`
              * `rightSum = max(0, 7) = 7`
              * **`maxi = max(15, 20 + 15 + 7) = 42`** (Path 15-20-7 found\!)
              * Returns `20 + max(15, 7) = 35`
      * At `findPathSum(-10)`:
          * `leftSum = 9`
          * `rightSum = max(0, 35) = 35`
          * `maxi = max(42, -10 + 9 + 35) = max(42, 34) = 42`
          * Returns `-10 + max(9, 35) = 25`
  * Main function returns `maxi`.

âœ… **Final Answer:** **42**

-----

ðŸ“Œ **Key Takeaways**

  * This problem requires a **post-order traversal**.
  * The recursive function must serve **two different purposes**: updating a global "split" path and returning a "one-way" path.
  * The `max(0, ...)` logic is the key to correctly handling negative-sum paths by giving the option to "stop" the path.