## **Maximum Depth of Binary Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

-----

### **1. Problem Understanding**

We are given:

  * A pointer to the `root` of a binary tree.

We need to find:

  * The **maximum depth** of the tree.

**Definition:** The maximum depth is the number of nodes along the **longest path** from the root node down to the farthest leaf node. A leaf node is a node with no children.

-----

### **2. When to Think of Recursion (for Trees)**

A problem is often a good candidate for recursion if:

1.  The problem's structure is **hierarchical or self-similar**, like a tree.
2.  The solution for a node can be easily defined in terms of the solutions for its **children** (left and right subtrees).
3.  A clear **base case** (like an empty or `NULL` node) exists.

-----

### **3. Why This Recursive Approach?**

  * This problem has a perfect **recursive structure**.
  * The **depth of an empty tree** (a `NULL` node) is `0`. This is our **base case**.
  * The **depth of a non-empty tree** is `1` (for the current node) plus the **maximum** of the depths of its left and right subtrees.
  * **Depth(node) = 1 + max(Depth(node-\>left), Depth(node-\>right))**

-----

### **4. Algorithm**

**Step-by-step:**

1.  Define the function `maxDepth(root)`.
2.  **Base Case:** If the `root` is `NULL`, the depth is `0`. Return `0`.
3.  **Recursive Step (Left):** Recursively find the depth of the left subtree: `lf = maxDepth(root->left)`.
4.  **Recursive Step (Right):** Recursively find the depth of the right subtree: `rf = maxDepth(root->right)`.
5.  **Combine Results:** The depth of the current tree is `1` (for the current `root` node) plus the *larger* of the two subtree depths.
6.  Return `1 + max(lf, rf)`.

-----

### **5. Time Complexity**

  * The function visits every node in the binary tree **exactly once**.
  * **O(N)**, where N is the total number of nodes in the tree.

-----

### **6. Space Complexity**

  * The space complexity is determined by the **recursion call stack**.
  * In the worst case (a completely skewed tree, like a linked list), the stack depth will be N.
  * In the best/average case (a balanced tree), the stack depth will be `log N`.
  * Therefore, the space complexity is **O(H)**, where H is the height of the tree. (H can be N in the worst case and `log N` in the best case).

-----

### **7. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL) return 0; // Base Case

        int lf = maxDepth(root->left); // Recursive call for left
        int rf = maxDepth(root->right); // Recursive call for right

        return 1 + max(lf,rf); // Combine results
    }
};
```

-----

### **8. Dry Run Example**

**Input Tree:**

```
    3
   / \
  9  20
     /  \
    15   7
```

**Execution Trace:**

```
maxDepth(3):
  lf = maxDepth(9):
    lf = maxDepth(NULL) -> returns 0
    rf = maxDepth(NULL) -> returns 0
    return 1 + max(0, 0) -> returns 1
  rf = maxDepth(20):
    lf = maxDepth(15):
      lf = maxDepth(NULL) -> returns 0
      rf = maxDepth(NULL) -> returns 0
      return 1 + max(0, 0) -> returns 1
    rf = maxDepth(7):
      lf = maxDepth(NULL) -> returns 0
      rf = maxDepth(NULL) -> returns 0
      return 1 + max(0, 0) -> returns 1
    return 1 + max(1, 1) -> returns 2
  return 1 + max(1, 2) -> returns 3
```

-----

 **Final Answer:** **3**

-----

 **Key takeaway:** Many tree problems can be solved by:

1.  Defining a **base case** (usually for a `NULL` node).
2.  Making recursive calls for the **left and right children**.
3.  **Combining** the results from those calls.

-----