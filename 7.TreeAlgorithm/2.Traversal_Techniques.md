# **Tree Traversal**

---

# Depth First Traversal (DFS)

## **1. In-order Traversal (Left → Root → Right)**

### **Definition**

Visit the left subtree first, then the root, then the right subtree.

### **Pseudo-code**

1. Traverse the **left** subtree
2. Visit the **root** node
3. Traverse the **right** subtree

### **C++ Code (Recursive)**

```cpp
void inOrderTraversal(TreeNode* root) {
    if(root == nullptr) return;
    inOrderTraversal(root->left);
    cout << root->val << " ";
    inOrderTraversal(root->right);
}
```

### **C++ Code (Iterative Version)**

```cpp
void inOrderIterative(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* curr = root;

    while(curr != nullptr || !st.empty()) {
        while(curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        curr = st.top();
        st.pop();

        cout << curr->val << " ";

        curr = curr->right;
    }
}
```

### **Use cases**

* Produces nodes in **sorted order** for BST
* Most commonly tested traversal

---

# **2. Pre-order Traversal (Root → Left → Right)**

### **Definition**

Visit the root first, then explore left subtree, then right subtree.

### **Pseudo-code**

1. Visit **root**
2. Traverse **left** subtree
3. Traverse **right** subtree

### **C++ Code (Recursive)**

```cpp
void preOrderTraversal(TreeNode* root) {
    if(root == nullptr) return;
    cout << root->val << " ";
    preOrderTraversal(root->left);
    preOrderTraversal(root->right);
}
```

### **C++ Code (Iterative Version)**

```cpp
void preOrderIterative(TreeNode* root) {
    if(root == nullptr) return;

    stack<TreeNode*> st;
    st.push(root);

    while(!st.empty()) {
        TreeNode* curr = st.top();
        st.pop();

        cout << curr->val << " ";

        if(curr->right) st.push(curr->right);
        if(curr->left) st.push(curr->left);
    }
}
```

### **Use cases**

* Used to **copy** a tree
* Used to generate prefix expressions

---

# **3. Post-order Traversal (Left → Right → Root)**

### **Definition**

Visit left subtree, then right subtree, and root at last.

### **Pseudo-code**

1. Traverse **left** subtree
2. Traverse **right** subtree
3. Visit **root**

### **C++ Code (Recursive)**

```cpp
void postOrderTraversal(TreeNode* root) {
    if(root == nullptr) return;
    postOrderTraversal(root->left);
    postOrderTraversal(root->right);
    cout << root->val << " ";
}
```

### **C++ Code (Iterative Version)**

(Using **two stacks** – easiest method)

```cpp
void postOrderIterative(TreeNode* root) {
    if(root == nullptr) return;

    stack<TreeNode*> st1, st2;
    st1.push(root);

    while(!st1.empty()) {
        TreeNode* curr = st1.top();
        st1.pop();
        st2.push(curr);

        if(curr->left) st1.push(curr->left);
        if(curr->right) st1.push(curr->right);
    }

    while(!st2.empty()) {
        cout << st2.top()->val << " ";
        st2.pop();
    }
}
```

### **Use cases**

* Used to **delete** or **free** a tree
* Generates postfix expressions

---

# Breadth First Traversal (BFS)

```cpp
void levelOrderTraversal(TreeNode* root) {
    vector<vector<int>> result;
    if(root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
        int size = q.size();
        vector<int> level;
        for(int i = 0; i < size; i++) {
            TreeNode* current = q.front();
            q.pop();
            if(current->left) q.push(current->left);
            if(current->right) q.push(current->right);
            level.push_back(current->val);
        }
        result.push_back(level);
    }
}
```

---