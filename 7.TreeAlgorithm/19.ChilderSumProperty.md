# **Children Sum Property – Detailed Notes**

## **1. Problem Definition**

You are given an arbitrary binary tree.
Your task is to convert it into a tree that satisfies the **Children Sum Property**, which states:

[
\text{node.data} = \text{(left child data)} + \text{(right child data)}
]

### **Mandatory Rules**

1. The **structure of the tree cannot be changed**.
2. You must ensure the property holds **for every node**.
3. You are **not allowed to decrement any node value**.
4. You may **increment** node values anywhere.
5. Since increments are allowed in many ways, **multiple valid solutions** may exist.

---

## **2. Example**

### **Given Input Tree**

```
        50
      /    \
     7      2
    / \    / \
   3   5  1  30
```

### **One Valid Converted Tree**

```
        50
      /    \
    19      31
   / \     /  \
 14   5   1    30
```

### **Another Valid Converted Tree**

```
        79
      /    \
    48      31
   / \     /  \
 43   5   1    30
```

Multiple outputs are possible because increases can be propagated in more than one manner.

---

# **3. Approaches Overview**

There are two well-known strategies:

### **A. Naive Approach (Post-order Adjustment)**

*Process children first, then fix parent.*

* Time: O(n²)
* Space: O(h)

### **B. Expected Approach (Top-Down Adjustment + Bottom-Up Fixing)**

*Ensure child nodes never fall short, then update parents on return.*

* Time: O(n)
* Space: O(h)

The expected approach is the standard interview solution.

---

# **4. Naive Approach (Post-order) – O(n²)**

## **4.1 Core Idea**

1. Recursively fix the left subtree.
2. Recursively fix the right subtree.
3. Once both children are valid, fix the current node.

This approach works bottom-up and directly uses the Children Sum Property at the local node level.

---

## **4.2 Calculating the Difference**

For each node:

[
\text{childrenSum} = \text{left.data} + \text{right.data}
]

[
\text{diff} = \text{childrenSum} - \text{node.data}
]

You will handle three cases:

### **Case 1: diff = 0**

Children sum matches parent. No change needed.

### **Case 2: diff > 0**

Children sum is greater than parent.
Increase parent value to match children sum.

### **Case 3: diff < 0**

Parent is larger than children sum.
Since we cannot decrease parent, we must
**increase a child (and possibly propagate this increment downward)**.

Incrementing a child requires ensuring the subtree below it still satisfies the property, which causes cascading updates.
This is the reason for O(n²) complexity.

---

## **4.3 Naive Approach Dry Run**

Starting with:

```
        50
      /    \
     7      2
    / \    / \
   3   5  1  30
```

### **Step 1: Fix left subtree**

For node 7:
children sum = 3 + 5 = 8
Parent 7 < 8 → increase 7 to 8.

```
     8
   /   \
  3     5
```

### **Step 2: Fix right subtree**

For node 2:
children sum = 1 + 30 = 31
Parent 2 < 31 → increase 2 to 31.

```
     31
   /    \
  1      30
```

### **Step 3: Fix root**

Left = 8
Right = 31
Sum = 39

Parent = 50, which is greater than children sum.
Difference = 50 − 39 = 11

We must increase children to reach a total of 50.
One possible way: increase left subtree to 19.

That requires adjusting its child (3 → 14).

Final result:

```
        50
      /    \
    19      31
   / \     /  \
 14  5   1    30
```

---

# **5. Naive Approach – Complexity**

* In the worst case, for every node we may propagate an increment down a long subtree.
* Worst-case time complexity: **O(n²)**
* Auxiliary space (recursion): **O(h)**

---

# **6. Expected Approach – O(n)**

This approach is both efficient and elegant.

## **6.1 Core Principle**

Two complementary actions:

### **Top-Down Phase:**

Ensure at every step that
[
\text{childrenSum} \ge \text{parent.data}
]

If the children sum is less than the parent value, increase one or both children.

### **Bottom-Up Phase:**

After recursion, update the current node as:

[
\text{node.data} = \text{left.data} + \text{right.data}
]

This ensures the Children Sum Property holds on the return path.

---

## **6.2 Why Top-Down Adjustment Is Necessary**

Suppose a parent is large but children are small.
Example from input:

Left subtree sum = 3 + 5 = 8
Right subtree sum = 1 + 30 = 31
Total = 39 but parent = 50

Since we cannot decrement 50, the only valid approach is to increase children before descending.
If we waited until post-order, we would have to fix it repeatedly, causing inefficiency.

---

## **6.3 Detailed Steps (Expected Method)**

### **Step 1: Going Down**

Compute:

[
childSum = left.data + right.data
]

Cases:

1. If **parent <= childSum**, update parent to childSum.
2. If **parent > childSum**, increase one child so that
   [
   childSum = parent
   ]

### **Step 2: Recurse into Left and Right Subtrees**

This ensures that children never lag behind requirements.

### **Step 3: Coming Up**

After children are already valid:

[
parent.data = left.data + right.data
]

Now the parent satisfies the property automatically.

---

# **7. Expected Approach – Complexity**

* **Each node is processed once.**
* No repeated propagation is needed.
* Time complexity: **O(n)**
* Space complexity: **O(h)** due to recursion.

---

# **8. Comparison Table**

| Approach                        | Main Concept                                  | Time  | Space |
| ------------------------------- | --------------------------------------------- | ----- | ----- |
| Naive (Postorder)               | Fix children first, then parent               | O(n²) | O(h)  |
| Expected (Top-down + Bottom-up) | Raise children when needed, fix parents later | O(n)  | O(h)  |

---

# **9. Key Takeaways**

1. Only **increments** are allowed.
2. Tree structure is fixed.
3. Multiple correct trees may result.
4. Post-order method works but is inefficient.
5. Top-down + bottom-up method is the preferred interview solution.
6. The top-down step prevents shortage problems later in recursion.
7. The bottom-up step guarantees the final property.

---

