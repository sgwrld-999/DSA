# Burning Tree — Complete Notes

## Problem

A fire starts at a given target node in a binary tree.
Every second, the fire spreads to:

* Left child
* Right child
* Parent

Since the binary tree does not store parent pointers, first convert it into an undirected graph.

Goal: Find the minimum time to burn the entire tree.

---

# 1. Converting Binary Tree into an Undirected Graph

### Why this step is needed

A binary tree allows only downward traversal (left and right).
To simulate burning, we must be able to move upward as well.
Therefore, treat the tree as a general graph.

### Method: `buildGraph(node, parent, graph)`

* Each node is connected to:

  * Its left child
  * Its right child
  * Its parent
* These are stored in an adjacency list:
  `unordered_map<int, vector<int>> graph`

### Steps

1. If node is null, return.
2. If parent exists:

   * Add edge: node → parent
   * Add edge: parent → node
     (Bidirectional)
3. Recursively build graph for left subtree.
4. Recursively build graph for right subtree.

This graph now allows movement in all directions.

---

# 2. Burning the Tree using BFS

### Why BFS?

Fire spreads level-by-level each second.
Each BFS level represents 1 second of spreading.

### What is used?

* `queue<int> q` → stores nodes burning at the current second
* `visited` → ensures no node burns twice
* `time` → counts total spreading time

### BFS logic

1. Push target into queue and mark visited.
2. While queue is not empty:

   * For all nodes at current level:

     * Visit all neighbours (left, right, parent)
     * If neighbour is unvisited:

       * Mark visited
       * Push to queue
       * Mark that something burned this second
   * After processing one level:

     * If at least one neighbour burned, increase time

Stop when BFS completes.

---

# 3. Final Answer

`time` contains the total time needed to burn the entire tree.

---

# Code (Given Code Explained)

```cpp
class Solution {
private:
    void buildGraph(Node* node, Node* parent,
                    unordered_map<int, vector<int>>& graph) {

        if (!node) return;

        if (parent) {
            graph[node->data].push_back(parent->data);
            graph[parent->data].push_back(node->data);
        }

        buildGraph(node->left, node, graph);
        buildGraph(node->right, node, graph);
    }

public:
    int minTime(Node* root, int target) {

        unordered_map<int, vector<int>> graph;
        buildGraph(root, nullptr, graph);

        unordered_set<int> visited;
        queue<int> q;

        q.push(target);
        visited.insert(target);

        int time = 0;

        while (!q.empty()) {

            int size = q.size();
            bool burned = false;

            while (size--) {

                int current = q.front();
                q.pop();

                for (int neighbour : graph[current]) {
                    if (!visited.count(neighbour)) {
                        visited.insert(neighbour);
                        q.push(neighbour);
                        burned = true;
                    }
                }
            }

            if (burned) time++;
        }

        return time;
    }
};
```

---

# Dry Run Example

Consider the tree:

```
        1
       / \
      2   3
     / \
    4   5
```

Target = 2

### Step 1: Build Graph

Graph (adjacency list):

* 1 → [2, 3]
* 2 → [1, 4, 5]
* 3 → [1]
* 4 → [2]
* 5 → [2]

---

# Start BFS from target = 2

### Initial:

Queue = [2]
Visited = {2}
Time = 0

---

### Level 1:

Nodes burning now: 2

Neighbours:

* 1 (unvisited) → add
* 4 (unvisited) → add
* 5 (unvisited) → add

Queue becomes: [1, 4, 5]
Something burned → time = 1

---

### Level 2:

Nodes burning now: 1, 4, 5

1 → neighbours: 2, 3

* 2 is visited
* 3 is unvisited → add

4 → neighbour: 2 (visited)
5 → neighbour: 2 (visited)

Queue becomes: [3]
Something burned → time = 2

---

### Level 3:

Nodes burning now: 3

3 → neighbour: 1 (visited)

No new nodes burned.

Queue becomes empty.

Stop BFS.

---

# Final Answer

Time = 2

The tree takes 2 seconds to burn completely starting from node 2.

---
