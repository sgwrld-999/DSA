## **Binary Tree Paths**

**Problem Link:** [LeetCode](https://leetcode.com/problems/binary-tree-paths/)

-----

### **1. Problem Understanding**

We are given the `root` of a binary tree. We need to return all **root-to-leaf paths** in any order.

**Format:**
The paths should be returned as strings, where nodes are connected by `"->"`.

**Example:**

```
Input:
   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]
```

-----

### **2. Intuition (Backtracking)**

  * To find every path from the top (root) to the bottom (leaves), we need to traverse every branch.
  * **Depth First Search (DFS)** is ideal here. We dive as deep as possible until we hit a leaf.
  * **Backtracking:** We need a way to "record" the nodes we visit as we go down. Once we hit a leaf and record that path, we must "remove" the current node from our record before going back up to explore a different branch.
      * *Action:* Add node to path.
      * *Recurse:* Go left, Go right.
      * *Backtrack:* Remove node from path.

-----

### **3. Algorithm**

This solution uses a **Two-Step Approach**:

**Step 1: Collect Paths (Integers)**

1.  Create a helper function `rootToLeaf`.
2.  Maintain a temporary `path` vector to store current node values.
3.  **Push** the current node's value into `path`.
4.  **Check Leaf:** If the node has no children (`left == null` && `right == null`), copy the current `path` into the main `ans` collection.
5.  **Recurse:** Call the function for left and right children.
6.  **Backtrack:** **Pop** the last element from `path` to return to the previous state before returning to the parent.

**Step 2: Format Output (Strings)**

1.  Iterate through the collected list of integer vectors.
2.  Convert each integer vector into a single string joined by `"->"`.
3.  Return the list of strings.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **$O(N)$**
      * We visit every node exactly once.
      * *Note:* Copying the path at leaf nodes and converting to strings adds some overhead proportional to the path length ($H$), effectively $O(N \cdot H)$ in the worst case, but generally considered linear with respect to the output size.
  * **Space Complexity:** **$O(H)$**
      * Recursion stack usage and the temporary `path` vector take space proportional to the height of the tree.

-----

### **5. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    // Helper 1: DFS to collect all paths as vectors of integers
    void rootToLeaf(TreeNode* root, vector<vector<int>>& ans, vector<int>& path) {
        if(root == nullptr) return;

        // 1. Action: Add current node to path
        path.push_back(root->val);

        // 2. Check Leaf: If no children, store the complete path
        if(root->left == nullptr && root->right == nullptr) {
            ans.push_back(path);
        }

        // 3. Recurse
        rootToLeaf(root->left, ans, path);
        rootToLeaf(root->right, ans, path);

        // 4. Backtrack: Remove current node before going back up
        path.pop_back();  
    }

    // Helper 2: Convert integer vectors to the required string format
    vector<string> convertPathToString(vector<vector<int>>& ans) {
        vector<string> stringAns;

        for(auto &vec : ans) {
            string path = "";
            for(int i = 0; i < vec.size(); i++) {
                path += to_string(vec[i]);
                // Add arrow only if it's not the last element
                if(i != vec.size() - 1)
                    path += "->";
            }
            stringAns.push_back(path);
        }
        return stringAns;
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<vector<int>> ans;
        vector<int> path;

        if(root == nullptr) return {};

        // Step 1: Get paths as integers
        rootToLeaf(root, ans, path);

        // Step 2: Convert to strings
        return convertPathToString(ans);
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
      1
     / \
    2   3
     \
      5
```

**Execution Trace:**

1.  **Start at 1:** `path = [1]`
2.  **Go Left to 2:** `path = [1, 2]`
      * Left child is NULL.
      * **Go Right to 5:** `path = [1, 2, 5]`
          * **5 is a Leaf.** Add `[1, 2, 5]` to `ans`.
          * Backtrack (pop 5): `path = [1, 2]`
      * Backtrack (pop 2): `path = [1]`
3.  **Go Right to 3:** `path = [1, 3]`
      * **3 is a Leaf.** Add `[1, 3]` to `ans`.
      * Backtrack (pop 3): `path = [1]`
4.  **End:** `ans = [[1, 2, 5], [1, 3]]`
5.  **Convert:**
      * `[1, 2, 5]` $\to$ `"1->2->5"`
      * `[1, 3]` $\to$ `"1->3"`

-----

### **7. Key Takeaways**

1.  **Backtracking Pattern:** The `push_back` $\to$ `recurse` $\to$ `pop_back` structure is standard for collecting paths in trees.
2.  **Leaf Logic:** Always check `!left && !right` to identify when a path ends.
3.  **Modular Code:** Separating the "logic of finding paths" from the "logic of formatting strings" makes the code cleaner, though slightly more verbose.