## **Binary Tree Zigzag Level Order Traversal**

**Problem Link:** [LeetCode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

-----

### 1\. Problem Understanding

We are given:

  * A pointer to the `root` of a binary tree.

We need to return:

  * A **level-by-level** traversal of the node's values, but with a "zigzag" or "alternating" order.
  * **Level 0:** Left-to-right
  * **Level 1:** Right-to-left
  * **Level 2:** Left-to-right
  * ...and so on.

**Example:**
For a tree `[3, 9, 20, null, null, 15, 7]`:

```
    3
   / \
  9  20
     /  \
    15   7
```

The zigzag output should be:

```
[
  [3],
  [20, 9],
  [15, 7]
]
```

-----

### 2\. When to Think of Queue (BFS)

1.  The problem asks for a **"level-by-level"** traversal.
2.  This is the classic signal for using **Breadth-First Search (BFS)**.
3.  The standard data structure for implementing BFS is a **Queue**.

-----

### 3\. The "Zigzag" Twist

  * A standard BFS (using a queue) *always* dequeues nodes from left to right for any given level.
  * We can **keep the standard BFS queue logic** (always enqueue `left` child, then `right` child).
  * The "twist" is not in how we *traverse*, but in how we *store* the values.
  * We can use a **boolean flag** (e.g., `isLeftToRightDirection`) to decide *where* in our `currentLevelValues` vector to place the node's value.

-----

### 4\. Algorithm (Step-by-Step)

1.  Initialize a `result` vector of vectors.
2.  If `root` is `NULL`, return the empty `result`.
3.  Initialize a `queue<TreeNode*> levelQueue` and push the `root`.
4.  Initialize a boolean flag `isLeftToRightDirection = true`.
5.  **Loop while `levelQueue` is not empty:**
    1.  Get the `nodesInCurrentLevel` (which is `levelQueue.size()`). This is crucial to ensure we only process one level at a time.
    2.  Initialize a `vector<int> currentLevelValues` of size `nodesInCurrentLevel`.
    3.  **Loop `i` from 0 to `nodesInCurrentLevel - 1`:**
          * Get the `currentNode` by dequeuing from `levelQueue`.
          * **Calculate the `insertIndex`:** This is the core of the zigzag logic.
              * If `isLeftToRightDirection` is `true`, the index is just `i`.
              * If `isLeftToRightDirection` is `false`, the index is `(nodesInCurrentLevel - 1 - i)`. This reverses the insertion order.
          * Place the value: `currentLevelValues[insertIndex] = currentNode->val`.
          * **Enqueue children (standard BFS):**
              * If `currentNode->left` exists, push it to `levelQueue`.
              * If `currentNode->right` exists, push it to `levelQueue`.
    4.  **After the inner loop (level is complete):**
          * Flip the direction: `isLeftToRightDirection = !isLeftToRightDirection`.
          * Add the `currentLevelValues` to the final `result`.
6.  Return `result`.

-----

### 5\. Time Complexity

  * **O(N)**: We visit every node in the tree exactly once.

### 6\. Space Complexity

  * **O(W)**, where `W` is the maximum width of the tree.
  * This is because the `levelQueue` will, in the worst case (a complete, balanced tree), hold all the nodes at the widest level (which can be up to `N/2` nodes, so it's also O(N)).

-----

### 7\. Code (Improved Variable Naming)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x, left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result; // The final list of levels

        if (root == NULL) return result;

        queue<TreeNode*> levelQueue; // Queue for standard BFS
        levelQueue.push(root);

        // Flag to control insertion order
        bool isLeftToRightDirection = true; 

        while (!levelQueue.empty()) {
            // Get the number of nodes at the current level
            int nodesInCurrentLevel = levelQueue.size();
            
            // Vector to store values for this level, pre-sized
            vector<int> currentLevelValues(nodesInCurrentLevel);

            for (int i = 0; i < nodesInCurrentLevel; i++) {
                // Get the next node from the queue
                TreeNode* currentNode = levelQueue.front();
                levelQueue.pop();

                // === This is the key "Zigzag" logic ===
                // Calculate where to insert the value based on direction
                int insertIndex = isLeftToRightDirection ? i : (nodesInCurrentLevel - 1 - i);
                currentLevelValues[insertIndex] = currentNode->val;
                // ======================================

                // Add children to the queue in the normal L->R order
                if (currentNode->left) {
                    levelQueue.push(currentNode->left);
                }
                if (currentNode->right) {
                    levelQueue.push(currentNode->right);
                }
            }

            // Flip the direction for the *next* level
            isLeftToRightDirection = !isLeftToRightDirection;

            // Add the completed level's values to the final result
            result.push_back(currentLevelValues);
        }
        return result;
    }
};
```

-----

### 8\. Dry Run Example

**Input Tree:** `[3, 9, 20, null, null, 15, 7]`
`result = []`, `levelQueue = [3]`, `isLeftToRight = true`

**While Loop 1:**

  * `nodesInCurrentLevel = 1`
  * `currentLevelValues = [ _ ]` (size 1)
  * **i = 0:**
      * `currentNode = 3` (Dequeue)
      * `insertIndex = (true ? 0 : 1-1-0) = 0`
      * `currentLevelValues[0] = 3`
      * Enqueue `9`, Enqueue `20`. `levelQueue = [9, 20]`
  * Flip `isLeftToRight = false`
  * `result.push_back([3])`

**While Loop 2:**

  * `nodesInCurrentLevel = 2`
  * `currentLevelValues = [ _, _ ]` (size 2)
  * **i = 0:**
      * `currentNode = 9` (Dequeue)
      * `insertIndex = (false ? 0 : 2-1-0) = 1`
      * `currentLevelValues[1] = 9`
  * **i = 1:**
      * `currentNode = 20` (Dequeue)
      * `insertIndex = (false ? 1 : 2-1-1) = 0`
      * `currentLevelValues[0] = 20`
      * Enqueue `15`, Enqueue `7`. `levelQueue = [15, 7]`
  * Flip `isLeftToRight = true`
  * `result.push_back([20, 9])`

**While Loop 3:**

  * `nodesInCurrentLevel = 2`
  * `currentLevelValues = [ _, _ ]` (size 2)
  * **i = 0:**
      * `currentNode = 15` (Dequeue)
      * `insertIndex = (true ? 0 : 2-1-0) = 0`
      * `currentLevelValues[0] = 15`
  * **i = 1:**
      * `currentNode = 7` (Dequeue)
      * `insertIndex = (true ? 1 : 2-1-1) = 1`
      * `currentLevelValues[1] = 7`
  * `levelQueue` is now empty.
  * Flip `isLeftToRight = false`
  * `result.push_back([15, 7])`

**While Loop 4:**

  * `levelQueue` is empty. Loop terminates.

**Final Answer:** `[[3], [20, 9], [15, 7]]`

-----

ðŸ“Œ **Key Takeaways**

  * This is a **standard BFS** problem with a minor "twist".
  * The core BFS logic (using a queue, looping `size` times per level, enqueuing children) **does not change**.
  * The only change is the **index** where you *insert* the value into the temporary `currentLevelValues` vector.
  * A boolean flag is the cleanest way to track the alternating insertion order.