## **Maximum Width of Binary Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/maximum-width-of-binary-tree/)

-----

### **1. Problem Understanding**

We need to find the **maximum width** of a binary tree.

  * The width of one level is defined as the length between the **left-most** and **right-most** non-null nodes, where the null nodes between the end nodes **are also counted** into the length calculation.
  * Essentially, imagine the tree is a full binary tree; we measure the distance between the first and last node at any specific level.

-----

### **2. Intuition (Indexing Strategy)**

To solve this efficiently without actually creating null nodes (which would waste huge memory), we can assign a unique **Index** to every node, just like in a Heap or Segment Tree array representation.

**Indexing Rules:**
If a parent node has index $i$:

1.  **Left Child Index:** $2 \times i + 1$
2.  **Right Child Index:** $2 \times i + 2$

**Calculating Width:**
For any given level, if the first node is at index $L$ and the last node is at index $R$:
$$Width = R - L + 1$$

**Why BFS?**
Since width is calculated **level-by-level**, a Breadth-First Search (Level Order Traversal) is the natural choice.

-----

### **3. Handling Overflow (The `unsigned long long`)**

  * In a skewed tree, indices can grow very large (exponentially).
  * For a depth of 30, indices approach $2^{30}$. For deep trees, indices can exceed the range of a standard 32-bit `int`.
  * **Solution:** We use `unsigned long long` (64-bit).
      * Even if the indices overflow and wrap around, the difference `lastNode - frontNode` remains correct in C++ for unsigned types (modular arithmetic), provided the actual *width* doesn't exceed the type's capacity (which it won't for valid inputs).

-----

### **4. Algorithm**

1.  **Data Structure:** Use a `queue` storing pairs: `{TreeNode* node, unsigned long long index}`.
2.  **Initialize:** Push `{root, 0}` into the queue. Set `maxWidth = 0`.
3.  **BFS Loop:**
      * Get the size of the current level.
      * Identify the index of the **first** node (`frontNode`) and the **last** node (`lastNode`) in the queue *currently*.
      * Update `maxWidth = max(maxWidth, lastNode - frontNode + 1)`.
      * **Process Level:** Iterate through the current level nodes:
          * Pop the node.
          * If `left` child exists, push it with index $2 \times \text{currIdx} + 1$.
          * If `right` child exists, push it with index $2 \times \text{currIdx} + 2$.
4.  **Return** `maxWidth`.

-----

### **5. Time & Space Complexity**

  * **Time Complexity:** $O(N)$
      * We visit every node exactly once.
  * **Space Complexity:** $O(W)$
      * $W$ is the maximum width of the tree (max nodes in the queue). In the worst case, this is $O(N)$.

-----

### **6. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    // Use unsigned long long to prevent overflow issues with large indices.
    // In C++, unsigned overflow wraps around definedly, so subtraction remains valid.
    typedef unsigned long long ll;

    void helperFun(TreeNode* root, ll &maxWidth){
        if (!root) return;

        // Queue stores {Node, Index}
        queue<pair<TreeNode*, ll>> que;
        que.push({root, 0});
        maxWidth = 0;

        while (!que.empty()) {
            int sizeOfLevel = que.size();
            
            // Get indices of the first and last nodes in this level
            ll frontNodeIdx = que.front().second;
            ll lastNodeIdx  = que.back().second;

            // Update logic: (RightIndex - LeftIndex + 1)
            maxWidth = max(maxWidth, lastNodeIdx - frontNodeIdx + 1);

            while (sizeOfLevel--) {
                TreeNode* currNode = que.front().first;
                ll currIdx = que.front().second;
                que.pop();

                // Push children with Heap-based indexing
                if (currNode->left)
                    que.push({currNode->left, 2 * currIdx + 1});

                if (currNode->right)
                    que.push({currNode->right, 2 * currIdx + 2});
            }
        }
    }

public:
    int widthOfBinaryTree(TreeNode* root) {
        ll maxWidth = 0;
        helperFun(root, maxWidth);
        return (int)maxWidth;
    }
};
```

-----

### **7. Dry Run Example**

**Input Tree:**

```
       1
     /   \
    3     2
   / \     \
  5   3     9
```

**Execution Trace:**

1.  **Level 0:**

      * Queue: `[{1, 0}]`
      * `frontIdx = 0`, `lastIdx = 0`. Width: $0 - 0 + 1 = 1$. `maxWidth = 1`.
      * Push children of 1:
          * Left (3) $\to$ index $2(0)+1 = 1$
          * Right (2) $\to$ index $2(0)+2 = 2$

2.  **Level 1:**

      * Queue: `[{3, 1}, {2, 2}]`
      * `frontIdx = 1`, `lastIdx = 2`. Width: $2 - 1 + 1 = 2$. `maxWidth = 2`.
      * Push children of 3 (idx 1):
          * Left (5) $\to$ $2(1)+1 = 3$
          * Right (3) $\to$ $2(1)+2 = 4$
      * Push children of 2 (idx 2):
          * Left (null)
          * Right (9) $\to$ $2(2)+2 = 6$

3.  **Level 2:**

      * Queue: `[{5, 3}, {3, 4}, {9, 6}]`
      * `frontIdx = 3`, `lastIdx = 6`. Width: $6 - 3 + 1 = 4$. `maxWidth = 4`.
      * *(Notice index 5 is skipped, representing the null child of node 2)*.

**Final Output:** `4`

-----

### **8. Key Takeaways**

1.  **Indexing is Key:** Treat the tree like an array where $L = 2i+1$ and $R = 2i+2$.
2.  **BFS Layering:** Processing the queue size-by-size allows us to access the `front` and `back` of the queue to get the exact width of that level instantly.
3.  **Data Types:** Always be mindful of integer overflow when calculating indices based on tree depth. `unsigned long long` is a safe bet here.

-----
