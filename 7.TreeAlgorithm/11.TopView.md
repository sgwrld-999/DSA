## **Top View of Binary Tree**

**Problem Link:** [GeeksforGeeks](https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1)

-----

### **1. Problem Understanding**

We are given a binary tree. Imagine you are looking at the tree from **directly above**. You need to print the nodes that are visible from the top, ordered from **left to right**.

**The Coordinate System (Horizontal Distance - HD):**

  * The **Root** is at horizontal distance `0`.
  * Moving **Left** subtracts 1 (`hd - 1`).
  * Moving **Right** adds 1 (`hd + 1`).

**Visibility Rule:**

  * If multiple nodes occupy the same Horizontal Distance (stacking vertically), only the **top-most** node (the one closest to the root, or the root itself) is visible.

-----

### **2. Intuition**

  * Since we need the "top-most" node for every vertical line, **Level Order Traversal (BFS)** is the perfect approach.
  * Why BFS? Because BFS visits nodes level-by-level (Level 0, then Level 1, etc.).
  * Therefore, the **first time** we encounter a specific Horizontal Distance during BFS, that node **must** be the highest one at that position. We store it and ignore any subsequent nodes at the same distance.

-----

### **3. Algorithm**

1.  **Initialization:**
      * Create a `queue` for BFS storing pairs: `{Node*, horizontal_distance}`.
      * Create a `map<int, int>` called `topNode`. Key = Horizontal Distance (HD), Value = Node Data. (Using `map` keeps keys sorted left-to-right automatically).
2.  **BFS Process:**
      * Push `{root, 0}` to the queue.
      * While the queue is not empty:
          * Pop the front element (`curr` node and `hd`).
          * **Crucial Check:** If `hd` is **NOT** in the map yet, add it: `topNode[hd] = curr->data`. (If it is already there, it means we found a node higher up previously, so we ignore the current one).
          * Push children:
              * Left child: `hd - 1`
              * Right child: `hd + 1`
3.  **Format Output:** Iterate through the map and store values in a vector.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **O(N log N)**
      * We visit every node once ($N$).
      * Insertion into a C++ ordered `map` takes $O(\log K)$ where $K$ is the width of the tree. In worst case, $O(N \log N)$.
  * **Space Complexity:** **O(N)**
      * To store nodes in the queue and the map.

-----

### **5. Code**

```cpp
/*
struct Node
{
    int data;
    Node* left;
    Node* right;
};
*/

class Solution {
public:
    vector<int> topView(Node *root) {
        if (!root) return {};
        
        // Map to store the pair <Horizontal Distance, Node Value>
        // We use a map because it sorts keys (HD) automatically (-2, -1, 0, 1...)
        map<int, int> topNode;
        
        // Queue for BFS: stores {Node pointer, Horizontal Distance}
        queue<pair<Node*, int>> q;   
        
        q.push({root, 0});
        
        while (!q.empty()) {
            auto p = q.front();
            q.pop();
            
            Node* curr = p.first;
            int hd = p.second;
            
            // CORE LOGIC: Only add the node if this HD hasn't been seen yet.
            // Since we do BFS, the first node seen at a specific HD is the highest one.
            if (topNode.find(hd) == topNode.end()) {
                topNode[hd] = curr->data;
            }
            
            // Push children with updated Horizontal Distances
            if (curr->left)  q.push({curr->left, hd - 1});
            if (curr->right) q.push({curr->right, hd + 1});
        }
        
        // Extract values from the map (sorted by HD)
        vector<int> ans;
        for (auto& x : topNode) {
            ans.push_back(x.second);
        }
        
        return ans;
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
       10
      /  \
    20    30
   /  \     \
  40  60     90
```

**Execution Trace:**

1.  **Init:** `q = [{10, 0}]`, `map = {}`
2.  **Pop 10 (hd 0):**
      * Map doesn't have 0. Insert `0 -> 10`.
      * Push Left: `{20, -1}`, Push Right: `{30, 1}`.
3.  **Pop 20 (hd -1):**
      * Map doesn't have -1. Insert `-1 -> 20`.
      * Push Left: `{40, -2}`, Push Right: `{60, 0}`.
4.  **Pop 30 (hd 1):**
      * Map doesn't have 1. Insert `1 -> 30`.
      * Push Right: `{90, 2}`.
5.  **Pop 40 (hd -2):**
      * Map doesn't have -2. Insert `-2 -> 40`.
6.  **Pop 60 (hd 0):**
      * **Map ALREADY has 0** (Value 10). Do nothing. (Node 60 is hidden below 10).
7.  **Pop 90 (hd 2):**
      * Map doesn't have 2. Insert `2 -> 90`.

**Final Map:** `{-2: 40, -1: 20, 0: 10, 1: 30, 2: 90}`
**Output Vector:** `[40, 20, 10, 30, 90]`

-----

### **7. Key Takeaways**

  * **Horizontal Distance (HD)** is the coordinate system for Top/Bottom/Vertical views.
  * **BFS (Level Order)** ensures that we see the top-most nodes first.
  * For Top View: **First node encountered** at an HD is the answer.
  * For Bottom View: **Last node encountered** at an HD is the answer (you would just overwrite the map entry every time).