# **Lowest Common Ancestor (LCA) in a Binary Tree – Notes**

## **1. Problem Definition**

Given a binary tree and two nodes `p` and `q`, the task is to find the **Lowest Common Ancestor (LCA)**, which is defined as:

> The lowest (i.e., deepest) node in the tree that has **both p and q as descendants**
> (a node can also be a descendant of itself).

### **Important Points**

1. You may move only *downwards* (left and right child).
2. The nodes `p` and `q` are guaranteed to exist in the tree.
3. The binary tree is *not* necessarily a BST, so no value comparisons can be used.
4. The LCA must be found using **pure recursion** over the tree structure.

---

# **2. Core Idea**

We solve LCA using **post-order recursion**:

1. Check if the current node is:

   * Null → nothing found
   * `p` or `q` → one target found
2. Recurse into:

   * Left subtree
   * Right subtree
3. Analyze the returned values:

   * If **both left and right return non-null**, this node is the LCA.
   * If **only one side returns non-null**, pass that result upwards.
   * If **no side finds anything**, return null.

This bottom-up mechanism ensures that the first (lowest) meeting point of `p` and `q` becomes the answer.

---

# **2.1 Additional Conceptual Explanation (Added Section)**

### **Understanding LCA Using “Signal Passing”**

Each node in the recursion behaves like a messenger.

It asks both subtrees:

> “Did you find `p`?”
> “Did you find `q`?”

Each subtree returns:

* A pointer to `p` (if found)
* A pointer to `q` (if found)
* `nullptr` (if nothing found)

### **What Happens During the Climb Back Up?**

The recursion moves bottom-up:

1. If a subtree returns a non-null pointer, the current node passes it upward.
2. When a node receives:

   * `p` from the left
   * `q` from the right
     (or the reverse)

   Then **this node must be the LCA**, because it is where both paths converge.

### **Why This Guarantees “Lowest” Common Ancestor**

The recursion returns the LCA **at the exact depth where both nodes are first seen together**.
Any ancestor above this point will also have both nodes below it, but this is the *lowest* one where the detection happens.

This is why the algorithm naturally finds the correct LCA without additional traversal or storage.

---

# **3. Explanation of the Algorithm**

### **Step 1 — Base Conditions**

If the current node is:

* `nullptr` → nothing to search
* equal to `p` → found `p`
* equal to `q` → found `q`

Return the node itself.

This acts as the *identity signal* that bubbles up.

---

### **Step 2 — Recursive Search**

Search both subtrees:

```
leftResult  = search in left subtree
rightResult = search in right subtree
```

Values returned can be:

* pointer to `p`
* pointer to `q`
* `nullptr`

---

### **Step 3 — Combine Results**

There are only 3 meaningful cases:

1. **Both sides return non-null**
   → one node was found on the left, the other on the right
   → current node is LCA

2. **Exactly one side returns non-null**
   → both nodes are located deeper on that single side
   → pass that pointer upward

3. **Both sides return null**
   → neither `p` nor `q` exist here
   → return null

---

# **4. Why This Algorithm Works**

The algorithm leverages **post-order traversal**:

* First explore deeper levels
* Bubble information upward
* Detect the split point (LCA)

It naturally locates the deepest node where `p` and `q` separate into two subtrees.

---

# **5. Time and Space Complexity**

### **Time Complexity**

Each node is visited once:

[
O(n)
]

### **Space Complexity**

Recursive call stack height = tree height:

* Worst case (skewed tree):
  [
  O(n)
  ]
* Best case (balanced tree):
  [
  O(\log n)
  ]

---

# **6. Final Code with Improved Variable Names**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* currentNode,
                                   TreeNode* nodeP,
                                   TreeNode* nodeQ) {

        // Base case: null or one of the targets found
        if (currentNode == nullptr ||
            currentNode == nodeP ||
            currentNode == nodeQ) {
            return currentNode;
        }

        // Recursively search in left and right subtrees
        TreeNode* leftSearchResult =
            lowestCommonAncestor(currentNode->left, nodeP, nodeQ);

        TreeNode* rightSearchResult =
            lowestCommonAncestor(currentNode->right, nodeP, nodeQ);

        // Case 1: Both sides found a target → current node is LCA
        if (leftSearchResult != nullptr &&
            rightSearchResult != nullptr) {
            return currentNode;
        }

        // Case 2: Only one side found something → return it
        if (leftSearchResult != nullptr) return leftSearchResult;
        return rightSearchResult; // may be null or valid node
    }
};
```

---

# **7. Full Dry Run (Added Section)**

Consider this tree:

```
           3
        /     \
       5       1
     /   \   /   \
    6     2 0     8
         / \
        7   4
```

Find LCA of `p = 5` and `q = 1`.

---

### **Call 1 — currentNode = 3**

* 3 is not p or q
* Recurse left → (node 5)
* Recurse right → (node 1)

---

### **Call 2 — currentNode = 5**

* 5 matches `p` → return 5 immediately

(leftSearchResult = 5 for the parent)

---

### **Call 3 — currentNode = 1**

* 1 matches `q` → return 1 immediately

(rightSearchResult = 1 for the parent)

---

### **Back at currentNode = 3**

* leftSearchResult = 5
* rightSearchResult = 1
* Both are non-null

So:

```
LCA = 3
```

---

# **8. Summary of the Intuition**

* Each recursive call asks its subtrees:
  “Did you find p?” and “Did you find q?”
* Subtrees pass signals upward.
* The first node to receive **both signals** is the LCA.
* Otherwise, any non-null signal is passed upward until the LCA is discovered.

This makes the algorithm simple, elegant, and guaranteed to find the lowest common ancestor.

---

