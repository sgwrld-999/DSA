## **Boundary Traversal of Binary Tree**

**Problem Link:** [GeeksforGeeks](https://practice.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1)

-----

### **1. Problem Understanding**

We are given:

  * A binary tree where nodes have a `data` field (unlike LeetCode's `val`).

We need to:

  * Compute the **Boundary Traversal** of the tree in an **anti-clockwise direction**.

**The Path consists of 3 Sections:**

1.  **Left Boundary:** Path from the root to the left-most node (excluding leaf nodes).
2.  **Leaf Nodes:** All leaf nodes from left to right.
3.  **Right Boundary:** Path from the root to the right-most node (excluding leaf nodes), added in **reverse order** (bottom-up).

**Important Constraint:** The `root` is part of the boundary but should not be duplicated. If the root is a leaf, it counts as a leaf node.

-----

### **2. Approach**

The problem is best solved by breaking it down into four distinct steps to avoid overlap/duplicates:

1.  **Handle Root:** Add the root explicitly first (unless it is a leaf, in which case it will be handled by the leaf step).
2.  **Left Boundary:** Traverse down the left side.
      * Always prefer `root->left`. If it doesn't exist, go `root->right`.
      * Stop if we hit a leaf node (leaves are handled separately).
3.  **Leaf Nodes:** Perform a standard traversal (Preorder/Inorder) to find all leaf nodes.
      * Add them as we encounter them to maintain left-to-right order.
4.  **Right Boundary:** Traverse down the right side.
      * Always prefer `root->right`. If it doesn't exist, go `root->left`.
      * Store nodes in a temporary structure (like a vector) and then add them to the result in **reverse** order.

-----

### **3. Algorithm**

1.  Initialize `vector<int> res`.
2.  If `root` is NULL, return `res`.
3.  If `root` is **not** a leaf, add `root->data` to `res`.
4.  Call `insertLeftBoundary(root, res)`:
      * Start from `root->left`.
      * While node exists and is not a leaf: Add data, move left (or right if left is null).
5.  Call `insertLeafNode(root, res)`:
      * Recursively visit nodes. If `isLeaf()` is true, add data.
6.  Call `insertRightBoundary(root, res)`:
      * Start from `root->right`.
      * While node exists and is not a leaf: Add data to `tempVec`, move right (or left if right is null).
      * Push elements from `tempVec` to `res` in reverse.
7.  Return `res`.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **O(N)**
      * Left Boundary: O(H)
      * Leaves: O(N) (We visit every node to check if it's a leaf)
      * Right Boundary: O(H)
      * Total is dominated by O(N).
  * **Space Complexity:** **O(H)** (Auxiliary)
      * Determined by the recursion stack height during leaf traversal and the temporary vector for the right boundary.

-----

### **5. Code**

```cpp
/*
// The platform already defines the Node structure like this:
struct Node {
    int data;
    Node *left;
    Node *right;
};
*/

class Solution {
private:
    // Helper: Check if a node is a leaf
    bool isLeaf(Node* root) {
        if (!root) return false;
        return (!root->left && !root->right);
    }
    
    // Helper: Insert left boundary nodes (excluding leaves)
    void insertLeftBoundary(Node* root, vector<int> &res) {
        Node* curr = root->left;
        while(curr) {
            // Add only if NOT a leaf
            if(!isLeaf(curr)) res.push_back(curr->data);
            
            // Move left if possible, otherwise right
            if(curr->left) curr = curr->left;
            else curr = curr->right;
        }
    }
    
    // Helper: Insert right boundary nodes (excluding leaves)
    void insertRightBoundary(Node* root, vector<int> &res) {
        Node* curr = root->right;
        vector<int> tempVec; // Needed to reverse the order later
        while(curr) {
            // Add only if NOT a leaf
            if(!isLeaf(curr)) tempVec.push_back(curr->data);
            
            // Move right if possible, otherwise left
            if(curr->right) curr = curr->right;
            else curr = curr->left;
        }
        
        // Add to result in reverse order (Bottom-Up)
        for(int i = tempVec.size() - 1; i >= 0 ; i--) {
            res.push_back(tempVec[i]);
        }
    }
    
    // Helper: Insert all leaf nodes
    void insertLeafNode(Node* root, vector<int> &res) {
        if(!root) return;
        
        // If leaf, add to result
        if(isLeaf(root)) {
            res.push_back(root->data);
            return;
        }
        
        // Recurse
        if(root->left) insertLeafNode(root->left, res);
        if(root->right) insertLeafNode(root->right, res);
    }
    
public:
    vector<int> boundaryTraversal(Node *root) {
        vector<int> res;
        if(!root) return res;
        
        // 1. Add root's value (Only if it's not a leaf)
        // If it is a leaf, step 3 will handle it.
        if (!isLeaf(root)) {
             res.push_back(root->data);
        }

        // 2. Add Left Boundary
        insertLeftBoundary(root, res);

        // 3. Add Leaf Nodes
        insertLeafNode(root, res);

        // 4. Add Right Boundary
        insertRightBoundary(root, res);
        
        return res;
    }
};
```

-----

### **6. Dry Run Example**

**Input:**

```
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
```

**Execution:**

1.  **Root:** `1` is not a leaf. `res = [1]`
2.  **Left Boundary:** Start at `2`. `2` is not a leaf. Add `2`. Move to `4`. `4` is a leaf (stop). `res = [1, 2]`
3.  **Leaf Nodes:**
      * DFS traverse.
      * Found `4` (Left child of 2). Add `4`. `res = [1, 2, 4]`
      * Found `5` (Right child of 2). Add `5`. `res = [1, 2, 4, 5]`
      * Found `6` (Left child of 3). Add `6`. `res = [1, 2, 4, 5, 6]`
      * Found `7` (Right child of 3). Add `7`. `res = [1, 2, 4, 5, 6, 7]`
4.  **Right Boundary:** Start at `3`. `3` is not a leaf. Add `3` to `tempVec`. Move to `7`. `7` is a leaf (stop).
      * `tempVec = [3]`.
      * Reverse add to `res`. `res = [1, 2, 4, 5, 6, 7, 3]`

**Final Output:** `[1, 2, 4, 5, 6, 7, 3]`

-----

### **7. Key Takeaways**

1.  **Modularize:** Breaking the problem into 3 distinct helpers (Left, Leaves, Right) makes the logic cleaner and prevents duplicate printing of nodes.
2.  **Leaf Checks:** Crucial\! The Left and Right boundary functions must strictly **ignore leaves**, or else the Leaf function will print them again (duplicates).
3.  **Reverse Right:** The right boundary is traversed top-down, but must be added bottom-up. A temporary vector or stack is needed.
4.  **Structure Members:** On platforms like GFG, the member is `data`; on LeetCode, it is `val`. Watch out for this syntax error.