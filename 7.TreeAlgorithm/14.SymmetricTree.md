## **Symmetric Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/symmetric-tree/)

-----

### **1. Problem Understanding**

We are given the `root` of a binary tree. We need to determine if the tree is a **mirror of itself** (i.e., symmetric around its center).

**Visualizing the Mirror:**
Imagine drawing a vertical line through the root. The left side of the tree must be the exact **reflection** of the right side.

-----

### **2. Intuition (The Mirror Property)**

A tree is symmetric if the left subtree and the right subtree are mirror images of each other.
To check if two trees (let's call them `Node1` and `Node2`) are mirrors:

1.  **Values must match:** `Node1->val == Node2->val`.
2.  **Structural Reflection:**
      * The **Left** child of `Node1` must match the **Right** child of `Node2` (**Outer** parts).
      * The **Right** child of `Node1` must match the **Left** child of `Node2` (**Inner** parts).

Unlike the "Same Tree" problem where we compared `Left vs Left` and `Right vs Right`, here we cross-compare.

-----

### **3. Algorithm**

1.  **Main Function:**
      * If the root is `NULL`, the tree is symmetric (return `true`).
      * Otherwise, start the helper function comparing `root->left` and `root->right`.
2.  **Helper Function (`checkIsSym`):**
      * **Base Case 1 (NULLs):**
          * If both nodes are `NULL`, they match (return `true`).
          * If only one is `NULL`, they don't match (return `false`).
          * *Code Shortcut:* `if(left == nullptr || right == nullptr) return left == right;`
      * **Base Case 2 (Values):**
          * If values are different, return `false`.
      * **Recursive Step (The Cross Check):**
          * Return true only if:
              * `left->left` matches `right->right` (**Outer**)
              * **AND**
              * `left->right` matches `right->left` (**Inner**)

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **$O(N)$**
      * We traverse the entire tree once. Every node is visited.
  * **Space Complexity:** **$O(H)$**
      * The space is used by the recursion stack.
      * In the worst case (linear tree), it is $O(N)$. In the best case (balanced tree), it is $O(\log N)$.

-----

### **5. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    // Helper function to compare two subtrees for mirror property
    bool checkIsSym(TreeNode* left, TreeNode* right){
        // 1. Handle NULL cases
        // If one is NULL and other isn't -> false
        // If both are NULL -> true
        if(left == nullptr || right == nullptr) return left == right;

        // 2. Check Values
        if(left->val != right->val) return false;

        // 3. Recursively check the mirror reflection:
        // Compare Outer: left's Left vs right's Right
        // Compare Inner: left's Right vs right's Left
        return checkIsSym(left->left, right->right) && checkIsSym(left->right, right->left);
    }
public:
    bool isSymmetric(TreeNode* root) {
        // An empty tree is symmetric
        if(root == nullptr) return true;

        // Start comparing the left and right subtrees
        return checkIsSym(root->left, root->right);
     }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
       1
     /   \
    2     2
   / \   / \
  3   4 4   3
```

**Execution Trace:**

1.  `isSymmetric(1)` calls `checkIsSym(Node 2_left, Node 2_right)`.
      * Values match (2 == 2).
      * **Check Outer:** `checkIsSym(Node 3_left, Node 3_right)`
          * Values match (3 == 3).
          * Left children (NULL vs NULL) -\> True.
          * Right children (NULL vs NULL) -\> True.
          * Returns **True**.
      * **Check Inner:** `checkIsSym(Node 4_left, Node 4_right)`
          * Values match (4 == 4).
          * Left children (NULL vs NULL) -\> True.
          * Right children (NULL vs NULL) -\> True.
          * Returns **True**.
      * Outer (True) && Inner (True) -\> Returns **True**.

 **Final Answer:** **True**

-----

### **7. Key Takeaways**

1.  **Mirror Logic:** Always think "Left vs Right" and "Right vs Left".
2.  **Top-Down Recursion:** We check the current nodes, then pass the responsibility to the children in a criss-cross manner.
3.  **Base Cases:** The `left == right` check for null pointers is a concise way to handle structural mismatches.