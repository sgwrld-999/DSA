# **Nodes at Distance K from a Target Node – Notes**

## **1. Problem Definition**

Given a binary tree, a target node, and an integer K, the task is to **find all nodes that are exactly K edges away from the target node**.

The distance between two nodes is measured in terms of the number of edges on the path connecting them.

### **Important Points**

1. Movement is possible in **three directions**:

   * Left child
   * Right child
   * Parent

2. The output should contain **all nodes at distance K**, regardless of direction.

3. A normal binary tree node does not store its parent, so a separate data structure is required.

---

# **2. Core Idea**

The solution uses a **two-phase approach**:

### **Phase 1: Construct a Parent Map**

Since each node only stores pointers to children, we must create a mapping:

$\text{child} \rightarrow \text{parent}$

This allows upward movement toward ancestors during BFS.

A level-order traversal (BFS) is used to record parents of each node.

---

### **Phase 2: Perform BFS Starting From the Target Node**

Once parent relationships are known, we do a **multi-directional BFS** from the target:

* Left child
* Right child
* Parent

We keep track of the current distance.
When the BFS reaches **distance K**, all nodes currently in the queue belong to the final answer.

A visited set ensures nodes are not revisited, preventing cycles.

---

# **2.1 Additional Conceptual Explanation (Added Section)**

### **Understanding the Problem as Graph Traversal**

In a binary tree, each node only has references to its children.
To find all nodes exactly K steps away from a target, we must move:

* Downward to left child
* Downward to right child
* Upward to parent

However, since tree nodes do not store parent pointers, upward movement is impossible unless we simulate it.

### **Transforming the Binary Tree into an Undirected Graph**

To support all three moves, we conceptually treat the tree as an undirected graph:

* Node ↔ Left child
* Node ↔ Right child
* Node ↔ Parent

This gives each node up to three valid neighbors.

### **Step 1 — Build the Parent Map**

Traverse the tree (BFS or DFS) and record:

$\text{parentMap[node]} = \text{parent}$

This step adds upward connectivity.

### **Step 2 — Perform BFS from the Target Node**

Start BFS from the target:

* Push target into queue
* Maintain visited set

At each BFS level:

* Visit left child if not visited
* Visit right child if not visited
* Visit parent if not visited

Continue until reaching distance K.

### **Step 3 — Collect Nodes**

When BFS reaches distance K:

* All nodes currently in the queue are exactly K edges away
* Store their values in a result vector
* Return the result

This approach is a direct application of graph BFS on an implicitly constructed undirected tree.

---

# **3. Explanation of the Algorithm**

### **Step 1 — Building the Parent Map**

* Begin at the root and push it into a queue.
* For each node:

  * If it has a left child, map left → parent
  * If it has a right child, map right → parent
* Continue BFS until the entire tree is processed.

This map allows bidirectional traversal during BFS.

---

### **Step 2 — BFS from the Target Node**

* Start BFS with the target as the initial node.
* Maintain a visited set to prevent revisiting.
* For each level of BFS:

  * If the level number equals K, stop expanding further.
  * Otherwise, move in all three possible directions:

    * Left child
    * Right child
    * Parent

All remaining nodes in the queue are exactly at distance K.

---

# **4. Why BFS Works Here**

This is essentially a shortest-path problem on an **implicit undirected graph**, where edges exist between:

* Node ↔ Left child
* Node ↔ Right child
* Node ↔ Parent

BFS naturally explores nodes one distance level at a time, making it the most efficient method for distance-based problems.

---

# **5. Time and Space Complexity**

### **Time Complexity**

* Building parent map: O(n)
* BFS traversal: O(n)

Overall:

$O(n)$

### **Space Complexity**

* Parent map: O(n)
* Queue for BFS: O(n)
* Visited set: O(n)

Overall:

$O(n)$

---

# **6. Final Code (Unmodified as Requested)**

```cpp
class Solution {
private:

    // ---------------------------------------------------------
    // 1. Build a mapping from every node → its parent node
    // ---------------------------------------------------------
    void buildParentMap(TreeNode* root,
                        unordered_map<TreeNode*, TreeNode*>& parentOf) {

        queue<TreeNode*> pendingNodes;
        pendingNodes.push(root);

        while (!pendingNodes.empty()) {

            TreeNode* current = pendingNodes.front();
            pendingNodes.pop();

            // Map left child → current (as parent)
            if (current->left) {
                parentOf[current->left] = current;
                pendingNodes.push(current->left);
            }

            // Map right child → current (as parent)
            if (current->right) {
                parentOf[current->right] = current;
                pendingNodes.push(current->right);
            }
        }
    }

    // ---------------------------------------------------------
    // 2. BFS starting from 'target' to find all nodes exactly at distance K
    // ---------------------------------------------------------
    vector<int> findNodesAtDistanceK(TreeNode* target,
                                     unordered_map<TreeNode*, TreeNode*>& parentOf,
                                     int distanceK) {

        queue<TreeNode*> levelQueue;
        unordered_set<TreeNode*> visited;

        levelQueue.push(target);
        visited.insert(target);

        int currentDistance = 0;

        while (!levelQueue.empty()) {

            int nodesAtThisLevel = levelQueue.size();

            // When we've reached the desired distance → stop expanding
            if (currentDistance == distanceK) break;

            currentDistance++;

            // Explore all nodes at currentDistance - 1
            while (nodesAtThisLevel--) {
                TreeNode* current = levelQueue.front();
                levelQueue.pop();

                // Move to left child
                if (current->left && !visited.count(current->left)) {
                    visited.insert(current->left);
                    levelQueue.push(current->left);
                }

                // Move to right child
                if (current->right && !visited.count(current->right)) {
                    visited.insert(current->right);
                    levelQueue.push(current->right);
                }

                // Move to parent
                if (parentOf.count(current) && !visited.count(parentOf[current])) {
                    visited.insert(parentOf[current]);
                    levelQueue.push(parentOf[current]);
                }
            }
        }

        // The remaining nodes in the queue are exactly at distance K
        vector<int> result;
        while (!levelQueue.empty()) {
            result.push_back(levelQueue.front()->val);
            levelQueue.pop();
        }

        return result;
    }

public:
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {

        unordered_map<TreeNode*, TreeNode*> parentOf;

        // Build parent mapping
        buildParentMap(root, parentOf);

        // BFS from target to find distance-k nodes
        return findNodesAtDistanceK(target, parentOf, k);
    }
};
```
