## **Vertical Order Traversal of a Binary Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)

-----

### **1. Problem Understanding**

We need to traverse a binary tree and group nodes based on their **vertical columns**.

**Coordinate System:**
Imagine the Root is at `(0, 0)`.

  * **Vertical (X-axis):** Moving **Left** subtracts 1 (`x - 1`), Moving **Right** adds 1 (`x + 1`).
  * **Level (Y-axis):** Moving **Down** adds 1 (`y + 1`).

**Sorting Requirements (Strict):**

1.  **Column Order:** Nodes in column `-1` come before column `0`, etc.
2.  **Row Order:** Within the same column, nodes higher up (level `0`) come before lower nodes (level `1`).
3.  **Value Order:** If two nodes are at the **exact same** row and column `(x, y)`, they must be sorted by their **values** in ascending order.

-----

### **2. Intuition & Data Structure**

Since we need to group data by `Vertical` -\> `Level` -\> `Values`, we need a data structure that maintains order automatically.

We can use a **Nested Map**:
`map < int, map < int, multiset<int> > >`

1.  **Outer Key (`int`):** Represents the **Vertical** ID (X-axis). `map` automatically sorts these (e.g., -2, -1, 0, 1, 2).
2.  **Inner Key (`int`):** Represents the **Level** ID (Y-axis). `map` automatically sorts these (e.g., level 0, level 1, level 2).
3.  **Inner Value (`multiset<int>`):** Stores the node **values**. `multiset` automatically sorts the values (e.g., {5, 6}) and handles duplicates, satisfying the third sorting requirement.

-----

### **3. Algorithm**

1.  **BFS Initialization:** Use a `queue` to perform a Level Order Traversal.
      * Queue stores: `{Node*, {vertical, level}}`.
      * Push `{root, {0, 0}}`.
2.  **Traversal:**
      * Pop the front element.
      * Insert the node's value into our data structure: `nodes[vertical][level].insert(val)`.
      * If left child exists: Push `{left, {vertical - 1, level + 1}}`.
      * If right child exists: Push `{right, {vertical + 1, level + 1}}`.
3.  **Build Result:**
      * Iterate through the outer map (Verticals).
      * For each vertical, iterate through the inner map (Levels).
      * Append all elements from the `multiset` to a temporary vector.
      * Push that vector to the final answer.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **O(N log N)**
      * We traverse $N$ nodes.
      * Inserting into the nested maps/multiset takes logarithmic time.
  * **Space Complexity:** **O(N)**
      * To store all nodes in the map and the queue.

-----

### **5. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void vertical_order_traversal(TreeNode* root, vector<vector<int>>& ans){
        if(root == nullptr) return;

        // Data Structure to store nodes:
        // Key 1 (int): Vertical (X-axis) -> Sorted by map
        // Key 2 (int): Level (Y-axis) -> Sorted by map
        // Value (multiset): Node Values -> Sorted by multiset
        map<int, map<int, multiset<int>>> nodesMap;

        // Queue for BFS: {Node, {Vertical, Level}}
        queue<pair<TreeNode*, pair<int,int>>> todo; 
        todo.push({root, {0, 0}});

        while(!todo.empty()){
            // 1. Retrieve current node details
            auto frontNode = todo.front();
            todo.pop();

            TreeNode* curr = frontNode.first;
            int vertical = frontNode.second.first;
            int level = frontNode.second.second;

            // 2. Insert into map
            nodesMap[vertical][level].insert(curr->val);

            // 3. Process Children
            if(curr->left){
                todo.push({curr->left, {vertical - 1, level + 1}});
            }
            if(curr->right){
                todo.push({curr->right, {vertical + 1, level + 1}});
            }
        }

        // 4. Flatten the map into the result vector
        // Iterate over verticals (columns)
        for(auto& verticalPair : nodesMap){
            vector<int> col;
            // Iterate over levels (rows) within that column
            for(auto& levelPair : verticalPair.second){
                // Add all sorted values from the multiset
                col.insert(col.end(), levelPair.second.begin(), levelPair.second.end());
            }
            ans.push_back(col);
        }
    }

public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        vector<vector<int>> ans;
        vertical_order_traversal(root, ans);
        return ans;
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
      1
    /   \
   2     3
  / \   / \
 4   5 6   7
```

*Assume node 5 is at (0, 2) and node 6 is at (0, 2) due to tree structure overlap.*

**Execution:**

1.  **Queue:** `[{1, {0,0}}]`
2.  **Pop 1:** Map -\> `[0][0] = {1}`. Push `2` at `{-1, 1}`, `3` at `{1, 1}`.
3.  **Pop 2:** Map -\> `[-1][1] = {2}`. Push `4` at `{-2, 2}`, `5` at `{0, 2}`.
4.  **Pop 3:** Map -\> `[1][1] = {3}`. Push `6` at `{0, 2}`, `7` at `{2, 2}`.
      * *Note: Node 5 and Node 6 are now targeting the same coordinate {0, 2}.*
5.  **Pop 4:** Map -\> `[-2][2] = {4}`.
6.  **Pop 5:** Map -\> `[0][2] = {5}`.
7.  **Pop 6:** Map -\> `[0][2]` now contains `{5, 6}` (Sorted by multiset).
8.  **Pop 7:** Map -\> `[2][2] = {7}`.

**Map Structure Final State:**

  * Vertical -2: `{4}`
  * Vertical -1: `{2}`
  * Vertical 0: Level 0 `{1}`, Level 2 `{5, 6}` -\> merged to `[1, 5, 6]`
  * Vertical 1: `{3}`
  * Vertical 2: `{7}`

**Result:** `[[4], [2], [1, 5, 6], [3], [7]]`

-----

### **7. Key Takeaways**

1.  **Coordinates on Trees:** Use `(vertical, level)` to map every node to a grid.
2.  **The "Same Position" Rule:** The problem states that if `(row, col)` are the same, sort by value. This is why `multiset` is essential.
3.  **Data Structure Power:** The `map<int, map<int, multiset<int>>>` does 90% of the work by automatically keeping keys and values sorted as we insert them.