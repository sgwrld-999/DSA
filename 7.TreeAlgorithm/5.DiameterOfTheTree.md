## **Diameter of a Binary Tree**

**Problem Link:** [LeetCode](https://www.google.com/search?q=https://leetcode.com/problems/diameter-of-a-binary-tree/)

-----

### 1\. Problem Understanding

We are given:

  * A pointer to the `root` of a binary tree.

We need to find:

  * The **diameter** of the tree.

**Definition:**
The **diameter** of a binary tree is the **length** of the **longest path** between *any two nodes* in the tree. The length of a path is the number of **edges** between the nodes.

> **Important:** This path does **not** necessarily have to pass through the root of the tree.

-----

### 2\. Recursive Intuition

For any given node `root`, the longest path in the tree can be in one of three places:

1.  Entirely within the **left subtree**.
2.  Entirely within the **right subtree**.
3.  **Passing through the `root` node**, connecting the deepest node in the left subtree to the deepest node in the right subtree.

The length of the path passing through the `root` is:
**`Height(root->left) + Height(root->right)`**

The diameter of the *entire tree* is the **maximum** of these three possibilities, calculated for *every node*.

-----

### 3\. Approach 1: Brute Force (O(N²))

This approach directly follows the recursive intuition. For every node, we calculate the diameter passing through it (`l_height + r_height`) and compare it with the diameters of its left and right subtrees.

  * **`height(root)` function:** A standard helper function to find the height (max depth) of a tree, which takes O(N) time.
  * **`diameterOfBinaryTree(root)` function:**
    1.  **Base Case:** If `root` is `NULL`, return 0.
    2.  **Calculate heights:**
          * `leftHeight = height(root->left)` (This is an O(N) operation)
          * `rightHeight = height(root->right)` (This is an O(N) operation)
    3.  **Calculate diameters:**
          * `leftDiameter = diameterOfBinaryTree(root->left)` (Recursive call)
          * `rightDiameter = diameterOfBinaryTree(root->right)` (Recursive call)
    4.  **Find the max:** The final answer is the maximum of:
          * The path through the current root: `leftHeight + rightHeight`
          * The diameter of the left subtree: `leftDiameter`
          * The diameter of the right subtree: `rightDiameter`

#### Why is this O(N²)?

  * The `diameterOfBinaryTree` function visits every node (N nodes).
  * For **each node**, it calls the `height()` function, which *also* traverses all descendants of that node (up to O(N) work).
  * This repeated recalculation of heights for subtrees leads to an O(N²) time complexity, similar to the naive "Balanced Binary Tree" solution.

-----

### 4\. Approach 2: Optimal (O(N))

This approach is much more efficient because it avoids re-computation. We can get all the information we need in a **single post-order traversal**.

  * **Idea:** We create a helper function that does two things at once:

    1.  **Returns:** The **height** of the current node (to be used by its parent).
    2.  **Updates (by reference):** A `maxi` variable that tracks the *overall maximum diameter found so far*.

  * **`calculateTreeDiameter(root, maxi)` helper function:**

    1.  **Base Case:** If `root` is `NULL`, return 0 (height of an empty tree is 0).
    2.  **Recursive Calls (Post-order):**
          * `leftHeight = calculateTreeDiameter(root->left, maxi)`
          * `rightHeight = calculateTreeDiameter(root->right, maxi)`
    3.  **Update Diameter:**
          * At the current `root`, the *diameter passing through it* is `leftHeight + rightHeight`.
          * We update our global maximum: `maxi = max(maxi, leftHeight + rightHeight)`.
    4.  **Return Height:**
          * The function must return the *height* of the current node to its parent, which is `1 + max(leftHeight, rightHeight)`.

  * The main `diameterOfBinaryTree` function just initializes `maxi = 0` and calls this helper.

#### Why is this O(N)?

  * This is a single post-order traversal.
  * Each node in the tree is visited **exactly once**.
  * At each node, we do a constant O(1) amount of work (two `max` operations).
  * This gives a total time complexity of **O(N)**.

-----

### 5\. Space Complexity (Both Approaches)

  * Both solutions use recursion. The space complexity is determined by the maximum depth of the **recursion call stack**.
  * This is equal to the height of the tree, **O(H)**.
      * **Best Case (Balanced Tree):** O(log N)
      * **Worst Case (Skewed Tree):** O(N)

-----

### 6\. Code (Both Approaches)

#### Approach 1: Brute Force O(N²) Solution

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

// Time Complexity: O(N*N)
// Space Complexity: O(H) (due to recursion stack)

class SolutionBrute {
public:
    // Standard O(N) height function
    int height(TreeNode* root) {
        if (root == nullptr) return 0;
        return 1 + max(height(root->left), height(root->right));
    }

    int diameterOfBinaryTree(TreeNode* root) {
        if (root == nullptr) return 0;

        // 1. Get height of left and right subtrees (O(N) work)
        int leftHeight = height(root->left);
        int rightHeight = height(root->right);

        // 2. Recursively find diameter of left and right subtrees
        int leftDiameter = diameterOfBinaryTree(root->left);
        int rightDiameter = diameterOfBinaryTree(root->right);

        // 3. The answer is the max of:
        //    a) Path through the current root (leftHeight + rightHeight)
        //    b) Diameter of the left subtree (leftDiameter)
        //    c) Diameter of the right subtree (rightDiameter)
        return max(leftHeight + rightHeight, max(leftDiameter, rightDiameter));
    }
};
```

-----

#### Approach 2: Optimal O(N) Solution

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

// Time Complexity: O(N)
// Space Complexity: O(H) (due to recursion stack)

class Solution {
public:
    // Helper function:
    // - Returns the height of the current node
    // - Updates 'maxi' (by reference) with the max diameter found
    int calculateTreeDiameter(TreeNode* root, int &maxi){
        if(root == nullptr) return 0;

        // Get heights of left and right subtrees
        int leftHeight = calculateTreeDiameter(root->left, maxi);
        int rightHeight = calculateTreeDiameter(root->right, maxi);

        // Update the max diameter.
        // The diameter passing through *this* node is leftHeight + rightHeight
        maxi = max(maxi, leftHeight + rightHeight);

        // Return the height of *this* node to its parent
        return 1 + max(leftHeight, rightHeight);
    }

    int diameterOfBinaryTree(TreeNode* root) {
        int maxi = 0; // This will store the maximum diameter
        calculateTreeDiameter(root, maxi);
        return maxi;
    }
};
```

-----

### 7\. Dry Run (Optimal O(N) Approach)

**Input Tree:**

```
       1
      / \
     2   3
    / \
   4   5
```

**Execution Trace (`calc` = `calculateTreeDiameter`):**

1.  `diameterOfBinaryTree(1)` initializes `maxi = 0`. Calls `calc(1, maxi)`.
2.  `calc(1, &maxi)`:
      * Calls `calc(2, &maxi)`:
          * Calls `calc(4, &maxi)`:
              * `root` is 4. Calls `calc(NULL, &maxi)` (left) -\> returns 0.
              * Calls `calc(NULL, &maxi)` (right) -\> returns 0.
              * `leftHeight = 0`, `rightHeight = 0`.
              * `maxi = max(0, 0 + 0) = 0`.
              * Returns `1 + max(0, 0) = 1`.
          * At `calc(2)`: `leftHeight = 1` (from 4).
          * Calls `calc(5, &maxi)`:
              * `root` is 5. Calls `calc(NULL, &maxi)` (left) -\> returns 0.
              * Calls `calc(NULL, &maxi)` (right) -\> returns 0.
              * `leftHeight = 0`, `rightHeight = 0`.
              * `maxi = max(0, 0 + 0) = 0`.
              * Returns `1 + max(0, 0) = 1`.
          * At `calc(2)`: `leftHeight = 1`, `rightHeight = 1`.
          * `maxi = max(0, 1 + 1) = 2`. (Path 4-2-5 found)
          * Returns `1 + max(1, 1) = 2`.
      * At `calc(1)`: `leftHeight = 2` (from 2).
      * Calls `calc(3, &maxi)`:
          * `root` is 3. Calls `calc(NULL, &maxi)` (left) -\> returns 0.
          * Calls `calc(NULL, &maxi)` (right) -\> returns 0.
          * `leftHeight = 0`, `rightHeight = 0`.
          * `maxi = max(2, 0 + 0) = 2`.
          * Returns `1 + max(0, 0) = 1`.
      * At `calc(1)`: `leftHeight = 2`, `rightHeight = 1`.
      * `maxi = max(2, 2 + 1) = 3`. (Path 4-2-1-3 or 5-2-1-3 found)
      * Returns `1 + max(2, 1) = 3`. (This return value is not used)
3.  `diameterOfBinaryTree(1)` returns the final `maxi` value.

 **Final Answer:** **3**

-----

 **Key Takeaway:**

  * This problem is a classic example of optimizing a "re-calculating" O(N²) tree recursion into a "pass-by-reference" or "pair-return" O(N) post-order traversal.
  * The key is to make the recursive function solve *two problems* at once: calculate the height for its parent, and update the global diameter.