## **Right Side View of Binary Tree**

**Problem Link:** [LeetCode](https://leetcode.com/problems/binary-tree-right-side-view/)

-----

### **1. Problem Understanding**

We are given the `root` of a binary tree. Imagine standing on the **right side** of the tree. You need to return the values of the nodes you can see, ordered from top to bottom.

**Key Insight:**

  * The "Right View" consists of the **last node** encountered at **each level** if we were reading the level from left to right.
  * Essentially, we need **one node per level** (the right-most one).

-----

### **2. Intuition (Recursive DFS)**

  * We can traverse the tree using **Depth First Search (DFS)**.
  * To make sure we find the "right-side" nodes first, we can modify the standard traversals.
  * **Reverse Pre-order Traversal:** Visit **Root** $\rightarrow$ **Right** $\rightarrow$ **Left**.
  * By visiting the **Right child first**, the first node we encounter at any new depth `level` is guaranteed to be the right-most visible node for that level.
  * If the right side is "shorter" than the left side, the traversal will eventually back up and visit the deeper nodes on the left side. Since those depth levels haven't been seen yet, they will be added to the view.

-----

### **3. Algorithm**

1.  **Initialize:** Create a result vector `ans` and call the recursive helper with `level = 0`.
2.  **Recursive Function (`helper`):**
      * **Base Case:** If `root` is `nullptr`, return.
      * **Check Visibility:** Compare the current `level` with the size of the `ans` vector.
          * If `level == ans.size()`, it means this is the **first time** we are visiting this particular depth. Since we are traversing Root $\rightarrow$ Right $\rightarrow$ Left, this must be the right-most node. Add it to `ans`.
      * **Recurse Right:** Call `helper(root->right, level + 1)` **first**.
      * **Recurse Left:** Call `helper(root->left, level + 1)` **second**.
3.  **Return:** The `ans` vector.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **$O(N)$**
      * We visit every node in the tree exactly once.
  * **Space Complexity:** **$O(H)$**
      * Determined by the recursion stack height ($H$).
      * Worst case (skewed tree): $O(N)$.
      * Best case (balanced tree): $O(\log N)$.

-----

### **5. Code**

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode() : val(0), left(nullptr), right(nullptr) {}
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
private:   
    // Helper for finding the right side of the tree
    // Logic: Root -> Right -> Left (Reverse Pre-order)
    void helper(TreeNode* root, vector<int>& ans, int level){
        // Base case
        if(root == nullptr) return;

        // Main body: If we are visiting this level for the first time
        if(ans.size() == level) ans.push_back(root->val);

        // Important: Go RIGHT first, then LEFT
        helper(root->right, ans, level + 1);
        helper(root->left, ans, level + 1);

        return;
    }
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;

        helper(root, ans, 0);

        return ans;
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**

```
       1  (Level 0)
     /   \
    2     3  (Level 1)
     \     \
      5     4  (Level 2)
     /
    6          (Level 3)
```

**Execution Trace:**

1.  **`helper(1, [], 0)`**:
      * `ans.size() (0) == level (0)`. Add **1**. `ans = [1]`
      * Recurse Right: `helper(3, [1], 1)`
2.  **`helper(3, [1], 1)`**:
      * `ans.size() (1) == level (1)`. Add **3**. `ans = [1, 3]`
      * Recurse Right: `helper(4, [1, 3], 2)`
3.  **`helper(4, [1, 3], 2)`**:
      * `ans.size() (2) == level (2)`. Add **4**. `ans = [1, 3, 4]`
      * Recurse Right: `helper(null)` $\rightarrow$ return.
      * Recurse Left: `helper(null)` $\rightarrow$ return.
      * Return to Node 3.
4.  **Back at Node 3**:
      * Recurse Left: `helper(null)` $\rightarrow$ return.
      * Return to Node 1.
5.  **Back at Node 1**:
      * Recurse Left: `helper(2, [1, 3, 4], 1)`
6.  **`helper(2, [1, 3, 4], 1)`**:
      * `ans.size() (3) != level (1)`. Do nothing (Level 1 already has node 3).
      * Recurse Right: `helper(5, [1, 3, 4], 2)`
7.  **`helper(5, [1, 3, 4], 2)`**:
      * `ans.size() (3) != level (2)`. Do nothing (Level 2 already has node 4).
      * Recurse Left: `helper(6, [1, 3, 4], 3)`
8.  **`helper(6, [1, 3, 4], 3)`**:
      * `ans.size() (3) == level (3)`. Add **6**. `ans = [1, 3, 4, 6]`
      * (Node 6 is visible because the right side ended at level 2).

**Final Result:** `[1, 3, 4, 6]`

-----

### **7. Key Takeaways**

1.  **`ans.size() == level`**: This is the magic condition. It ensures we only take the *first* node encountered for every depth level.
2.  **Traversal Order Matters**:
      * **Right View**: Root $\rightarrow$ **Right** $\rightarrow$ Left
      * **Left View**: Root $\rightarrow$ **Left** $\rightarrow$ Right
3.  **DFS vs BFS**:
      * BFS (Queue) is also valid (just take the last element of the level).
      * DFS (Recursion) is often shorter and cleaner to write.