## **Path to Given Node**

**Problem Link:** [InterviewBit](https://www.interviewbit.com/problems/path-to-given-node/)

-----

### **1. Problem Understanding**

We are given:

  * The `root` of a binary tree.
  * An integer `B` (target value).

We need to return:

  * A vector representing the **path** from the Root to the node with value `B`.
  * The path should contain all node values starting from the `root` down to `B`.

[Image of Binary Tree Path Finding]

-----

### **2. Intuition (Backtracking)**

  * We need to explore the tree to find `B`.
  * Since we need the specific path leading to `B`, we can keep adding nodes to a list as we traverse down (`push_back`).
  * If we reach a "dead end" (a leaf node that isn't `B`, or a subtree that doesn't contain `B`), we must **remove** the last added node (`pop_back`) before going back up to try a different branch.
  * This "Try $\rightarrow$ Fail $\rightarrow$ Undo" logic is the definition of **Backtracking**.

-----

### **3. Algorithm**

1.  **Helper Function (`getPath`):**

      * **Base Case:** If `root` is `NULL`, return `false` (path not found).
      * **Action:** Add the current `root->val` to the `arr`.
      * **Success Check:** If `root->val == x`, we found the target\! Return `true`.
      * **Recursive Step:**
          * Recursively check the **Left** subtree. If it returns `true`, then `B` is down that side. Return `true` immediately (stop searching).
          * Recursively check the **Right** subtree. If it returns `true`, return `true`.
      * **Backtrack:** If `B` was not found in the Left or Right subtrees, it means the current node is **not** part of the path. **Pop** it from `arr` and return `false`.

2.  **Wrapper Function (`solve`):**

      * Handle edge case (empty tree).
      * Call the helper.
      * Return the filled `arr`.

-----

### **4. Time & Space Complexity**

  * **Time Complexity:** **$O(N)$**
      * In the worst case, we might traverse every node in the tree before finding `B` (or realizing `B` doesn't exist).
  * **Space Complexity:** **$O(H)$**
      * $H$ is the height of the tree.
      * This space is used by the recursion stack and the `arr` vector (which stores the path).

-----

### **5. Code**

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 * int val;
 * TreeNode *left;
 * TreeNode *right;
 * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    // Returns true if the path to 'x' is found, updating 'arr' along the way.
    bool getPath(TreeNode* root, vector<int> &arr, int x) {
        // Base case: Dead end
        if (!root)
            return false;

        // 1. Add current node to the path
        arr.push_back(root->val);

        // 2. Check if we found the target
        if (root->val == x)
            return true;

        // 3. Recursively search Left OR Right
        // If either returns true, propagate the success up.
        if (getPath(root->left, arr, x) || getPath(root->right, arr, x))
            return true;

        // 4. Backtrack: If target not found in subtrees, remove current node
        arr.pop_back();
        return false;
    }

    vector<int> solve(TreeNode* A, int B) {
        vector<int> arr;

        if (A == NULL)
            return arr;

        getPath(A, arr, B);

        return arr;
    }
};
```

-----

### **6. Dry Run Example**

**Input Tree:**
Target `B = 5`

```
       1
     /   \
    2     3
         / \
        4   5
```

**Execution Trace:**

1.  **Visit 1:** `arr = [1]`. Target (5)? No.
2.  **Recurse Left (2):**
      * **Visit 2:** `arr = [1, 2]`. Target? No.
      * Left child is NULL $\rightarrow$ false.
      * Right child is NULL $\rightarrow$ false.
      * **Backtrack:** Pop 2. `arr = [1]`. Return `false`.
3.  **Recurse Right (3):**
      * **Visit 3:** `arr = [1, 3]`. Target? No.
      * **Recurse Left (4):**
          * **Visit 4:** `arr = [1, 3, 4]`. Target? No.
          * Backtrack (children null). Pop 4. `arr = [1, 3]`. Return `false`.
      * **Recurse Right (5):**
          * **Visit 5:** `arr = [1, 3, 5]`. Target? **YES\!**
          * Return `true`.
      * Right call returned `true`, so 3 returns `true`.
4.  Right call returned `true`, so 1 returns `true`.

**Final Output:** `[1, 3, 5]`

-----

### **7. Key Takeaways**

1.  **`push_back` before checks:** We tentatively add the node to the path assuming it *might* lead to the target.
2.  **`pop_back` on failure:** If the recursive calls return `false`, we know this node led nowhere, so we must remove it.
3.  **Boolean Return Type:** The helper function returns `bool` to tell the parent "Stop searching, I found it\!" or "I didn't find it, keep looking."